---
title: "🌦🌦前端大文件上传"
date: 2022-07-12
tags: 
- 开发日常
---
#### 背景：
前端文件上传是非常普遍的功能，当需要上传大文件时会有以下问题。

1.前后端上传时间限制，一次性传输大小限制。
2.上传时间长，无进度条，体验差。
3.网络抖动等，失败后需要重新上传。

主要步骤：

**加载文件 ➡️ 分片 ➡️ 上传**
#### 1.浏览器加载文件

```html
--- html vue----
<el-button type="plain" size="small" @click="$refs.refFile.click()">打开文件</el-button>
<input type="file" id="files" ref="refFile" style="display: none" accept=".xml, .json .png .jpg .zip" @change="importLocalFile" />
```

这一步主要是把文件读取到内存里。

this.$refs.refFile.files是 FileList类型。

this.$refs.refFile.files[0] 是File类型的包装器。

> File FileList FileReader关系：
FileReader只能读取 File或者 blob对象，File对象是[`FileList`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileList)的子集，constructor ==  Blob, 有slice方法。

#### 2.上传文件方式选择
文件上传采用 formData形式，而不是json。原因json传参需要JSON. stringify序列化
比如一下代码：
```
var xhr = new XMLHttpRequest();
xhr.open('post','http://localhost:3000/ajaxpost');
xhr.setReuqestHeader('Content-Type','application/json');
var params = JSON.stringify({
    city: '重庆',
    spcial: '山城'
})
xhr.send(params);
xhr.onload = function () {
    console.log(xhr.responseText);    
}
```

在序列化过程中，会抹掉一些比如 function File blob的对象，所以采用formData形式进行文件上传。


#### 3.分片上传

File对象可以使用，slice + File.size，对文件进行切割，切割后的chunk实际上是浏览器对象Blob。

```

const chunkSize = 1024;

const importLocalFile = () => {
      const selectFile = this.$refs.refFile.files[0]; // File对象
      chunkedUpload(selectFile)
}

async function chunkedUpload(file) {
  for (let start = 0; start < file.size; start += chunkSize) {
      const chunk = file.slice(start, start + chunkSize); //分片 blob对象
      const fd = new FormData();
      fd.append("data", chunk);
      // 上传 利用async实现，同步请求
      await fetch(url, { method: "post", body: fd }).then((res) =>
        res.text()
      );
  }
}
```
