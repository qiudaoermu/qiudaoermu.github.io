{"meta":{"title":"Hexo","subtitle":"","description":"test description","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"🐓🥚一键同步简书的文章到-GitHub-Pages","slug":"🐓🥚一键同步简书的文章到-GitHub-Pages","date":"2022-06-03T16:00:00.000Z","updated":"2022-06-10T01:04:40.095Z","comments":true,"path":"2022/undefined/03/🐓🥚一键同步简书的文章到-GitHub-Pages/","link":"","permalink":"http://example.com/2022/undefined/03/%F0%9F%90%93%F0%9F%A5%9A%E4%B8%80%E9%94%AE%E5%90%8C%E6%AD%A5%E7%AE%80%E4%B9%A6%E7%9A%84%E6%96%87%E7%AB%A0%E5%88%B0-GitHub-Pages/","excerpt":"","text":"简书的文章写完后，想同步到github的博客，这样你的博客有可能送到北极也说不定呢🥳🥳。 首先你要有一个github Page，现在有ruby和node.js版的，我用的这个模版，jekyll，免费快速搭建博客模版，你也可以选择其它的。 1.创建github Page1.1 新增仓库 userName.github.io，让后就可以打开这个https://userName.github.io1.2 下载仓库代码 https://github.com/Huxpro/huxpro.github.io到你的仓库2.利用脚本下载简书文章下载userName.github.io仓库代码，在项目根目录中建立如下文件夹新建 setUp.js,这里只展示主要代码，详细信息可查看github仓库 2.1下载简书文章简书有一键下载功能， 接口：https://www.jianshu.com/backup/download我写了一个脚本，可以直接下载到本地 12345678910(async () =&gt; &#123; await download( config.downloadUrl, // 下载连接 https://www.jianshu.com/backup/download config.downloadPath, // 下载后的文件路径&#123; headers: &#123; Cookie: config.cookie, // 你的简书cookie，很好找的 &#125;, &#125;);&#125;)() 2.2 解压下载文章压缩包删除上次解压的文件夹，找到最新的压缩文件，加压到output文件夹 12345678910111213141516171819unCompress() &#123; this.deleteUnrarDir(); const inputRarPath = this.newestRar(); exec( `unar $&#123;inputRarPath&#125; -o $&#123;this.unRarPath&#125;`, (err, stdout, stderr) =&gt; &#123; if (err) &#123; console.log(err); return; &#125; // 简书文章分为不同累不，解压到不同文件夹 let childDirs = fs.readdirSync(this.unCompressPath()); childDirs.forEach((item) =&gt; &#123; file.addTags(this.unCompressPath() + &quot;/&quot; + item + &quot;/&quot;); &#125;); if (stderr) console.error(`stderr: $&#123;stderr&#125;`); &#125; ); &#125; 2.3 为文章打Tagjekyll要根据文件头的Tag，生成文章信息，标题，日期，文章分类。格式如下 12345678--- layout: post tilte: &quot;2018-12-08-🦕🦕---React-如何阻止事件冒泡？.md&quot; date: 2018-12-08- tags: - 开发日常--- output里的文章打Tag后，复制到_post(默认文件夹)里，文章头如果没有日期，自动加上 123456789101112131415161718192021222324addTags(unarTagPath) &#123; // unarTagPath ...output fs.readdir(unarTagPath, &quot;utf8&quot;, (err, fileList) =&gt; &#123; if (err) throw err; fileList.forEach((excludeDatePrexFile) =&gt; &#123; // 获取文件后缀名 const filePath = unarTagPath + excludeDatePrexFile; const postContent = this.readFile( filePath, excludeDatePrexFile, this.prex ); this.addTagsOnHeader(filePath, postContent); this.renameFileByAddDatePrexInUnarTagPath( unarTagPath, this.prex, excludeDatePrexFile ); &#125;); &#125;);&#125; 3.提交到githubgithub会自动构建你发布的文章 遇到的问题，集中在：1.了解http协议 （request，response）2.如何处理不同场景下的响应体 （response， body）3.响应头中的 content-type 与响应数据对应的关系4.简书markdown，解析和jekyll不太一样，可能会样式错乱","categories":[],"tags":[{"name":"实践堂","slug":"实践堂","permalink":"http://example.com/tags/%E5%AE%9E%E8%B7%B5%E5%A0%82/"}]},{"title":"🐓🥚-HBuilderX-uni-app--h5端构建发布实践","slug":"🐓🥚-HBuilderX-uni-app--h5端构建发布实践","date":"2022-05-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.094Z","comments":true,"path":"2022/undefined/24/🐓🥚-HBuilderX-uni-app--h5端构建发布实践/","link":"","permalink":"http://example.com/2022/undefined/24/%F0%9F%90%93%F0%9F%A5%9A-HBuilderX-uni-app--h5%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"背景：uni-app h5端，需要打包成文件上传到服务器，由于系统隔离原因，代码平台无法使用自身的构建工具，只能自己写一个了。 流程图 架构图 uni-app提供了两套机制，HBuilderX，GUI方式和vue-cli，团队选择了GUI。可视化的方式比较简单，HBuilderX内置相关环境，开箱即用，无需配置nodejs。 客户端项目文件夹 HBuilderX本地静态资源构建HBuilderX可以在界面构建也可以使用命令行构建方式: $ cli publish --platform h5 --project &lt;projectName&gt; 打包文件夹地址/unpackage/dist/build/h5/ 压缩静态文件安装 compressing 1$ npm i compressing -s 使用compressing对静态文件压缩，生成h5.zipcompressDir.js 1234567891011121314151617181920var compressing = require(&quot;compressing&quot;);let fs = require(&quot;fs&quot;);const options = &#123; targetPath: &quot;/unpackage/dist/build/h5/&quot;, outPut: &quot;/unpackage/dist/build/h5.zip&quot;,&#125;;let pathout = process.cwd() + options.targetPath;let outPath = process.cwd() + &quot;/&quot; + options.outPut;compressing.zip .compressDir(pathout, outPath) .then(() =&gt; &#123; console.log(&quot;compress h5 folder done...&quot;); &#125;) .catch((err) =&gt; &#123; console.error(&quot;unzip&quot;); &#125;); 上传到服务器上传静态资源h5.zip安装 needle 1$ npm i needle -S 服务端,needle上传到服务器needle.js 1234567891011121314151617181920212223242526272829303132333435const needle = require(&quot;needle&quot;);const fs = require(&quot;fs&quot;);var colors = require(&quot;colors&quot;);colors.setTheme(&#123; custom: [&quot;white&quot;, &quot;bgGreen&quot;], error: [&quot;white&quot;, &quot;bgBlue&quot;],&#125;);let pwd = process.cwd();const buffer = fs.readFileSync(pwd + &quot;/unpackage/dist/build/h5.zip&quot;);// 服务器地址两个let url = [ &quot;http://xxx/file/uploading&quot;, &quot;http://xxx/file/uploading&quot;,];const data = &#123; file: &#123; buffer: buffer, filename: &quot;mypackage.zip&quot;, content_type: &quot;application/octet-stream&quot;, &#125;,&#125;;// the callback is optional, and needle returns a `readableStream` object// that triggers a &#x27;done&#x27; event when the request/response process is complete.url.forEach((item) =&gt; &#123; const site = item.replace(&quot;/file/uploading&quot;, &quot;&quot;); console.log(`service $&#123;site&#125; uploading...`.error); needle.post(item, data, &#123; multipart: true &#125;, function (err, resp, body) &#123; err &amp;&amp; console.error(err); console.log(`service $&#123;site&#125; upload done...`.custom); &#125;);&#125;); 服务端在服务器上部署node服务传输文件app.js，在linux上，1000端口起一个服务，接受的时候打上时间标签，便于回滚。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const express = require(&#x27;express&#x27;);const compressing = require(&quot;compressing&quot;);const app = express();const multiparty = require(&#x27;multiparty&#x27;);const fs = require(&#x27;fs&#x27;);const &#123; timestampToFile &#125; = require(&quot;./until&quot;);const path = require(&#x27;path&#x27;);const rootPath = path.resolve(__dirname, &#x27;./public&#x27;);/* 上传接口 */app.post(&#x27;/file/uploading&#x27;, (req, res, next) =&gt; &#123; /* 生成multiparty对象，并配置上传目标路径 */ const form = new multiparty.Form(); /* 设置编辑 */ form.encoding = &#x27;utf-8&#x27;; // 设置文件存储路劲 form.uploadDir = rootPath; // 设置文件大小限制 // form.maxFields = 1000; //设置所有文件的大小总和//上传后处理 form.parse(req, (err, fields, files) =&gt; &#123; const inputFile = files.file[0]; const uploadedPath = inputFile.path; // nginx 静态资源指向目录 const dstPath = uploadDirPath + &quot;/&quot; + &quot;h5-&quot; + timestampToFile() + &quot;.zip&quot;; // 重命名为真实文件名 fs.rename(uploadedPath, dstPath, (err) =&gt; &#123; if (err) &#123; console.log(&#x27;rename error:&#x27; + err); &#125; else &#123; console.log(&#x27;rename ok&#x27;); &#125; &#125;); &#125; res.writeHead(200, &#123; &#x27;content-type&#x27;: &#x27;text/plain;charset=utf-8&#x27; &#125;); res.write(&#x27;200&#x27;); res.end(); &#125;);&#125;);app.listen(1000); 一键发布最后命令放在package.json中 12345678&quot;scripts&quot;: &#123; //发布 &quot;pub:prod&quot;: &quot;cli publish --platform h5 --project xxx &amp;&amp; npm run compress &amp;&amp; npm run uploadToService&quot;, &quot;compress&quot;: &quot;node ./upload-script/compressDir.js&quot;, &quot;uploadToService&quot;: &quot;node ./upload-script/needle.js &quot; // 回滚 &quot;backTrace&quot;: &quot;node ./upload-script/backTrace.js &#125;, 1$ npm run pub:prod 版本回滚node-ssh可以远程登录服务器，并进行文件操作，把上传的zip复制到nginx静态目录里，替换到当前的。 1$ npm i node-ssh -S traceBack.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const &#123; NodeSSH &#125; = require(&quot;node-ssh&quot;);const arg = process.argv.splice(2)const ssh = new NodeSSH();const outPath = &quot;/usr/local/nginx/node-upload/public/list&quot;;ssh .connect(&#123; host: &quot;xxx.xxx&quot;, username: &quot;root&quot;, password: &quot;xxxxxxx&quot;, &#125;) .then(function () &#123; // 列进所有部署包 if (`$&#123;arg&#125;` === &quot;ls&quot;) &#123; ssh.execCommand(`ls`, &#123; cwd: `$&#123;outPath&#125;` &#125;).then(function (result) &#123; if (result.stderr) &#123; console.error(result.stderr); return; &#125; console.log(result.stdout); &#125;); return; &#125; // 复制文件到 nginx 静态目录下 ssh .execCommand(`cp $&#123;arg&#125; /usr/local/nginx/html`, &#123; cwd: `$&#123;outPath&#125;`, &#125;) .then(function (result) &#123; if (result.stderr) &#123; console.error(result.stderr); return; &#125; &#125;); // 解压相关zip ssh .execCommand(`unzip -o $&#123;arg&#125;`, &#123; cwd: `/usr/local/nginx/html`, &#125;) .then(function (result) &#123; if (result.stderr) &#123; console.error(result.stderr); return; &#125; console.log(result.stdout); &#125;); &#125;); 列举所有可用版本 $ npm backTrace ls 使用你要回滚的版本$ npm backTrace h5-2022-5-25-17:49:43.zip 项目代码地址","categories":[],"tags":[{"name":"实践堂","slug":"实践堂","permalink":"http://example.com/tags/%E5%AE%9E%E8%B7%B5%E5%A0%82/"}]},{"title":"☀️☀️装饰器模式实现","slug":"☀️☀️装饰器模式实现","date":"2022-05-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.243Z","comments":true,"path":"2022/undefined/24/☀️☀️装饰器模式实现/","link":"","permalink":"http://example.com/2022/undefined/24/%E2%98%80%EF%B8%8F%E2%98%80%EF%B8%8F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"","categories":[],"tags":[{"name":"编程范式","slug":"编程范式","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"}]},{"title":"🗳🗳-前端基建方向","slug":"🗳🗳-前端基建方向","date":"2022-05-21T00:00:00.000Z","updated":"2022-06-10T08:01:24.736Z","comments":true,"path":"2022/undefined/21/🗳🗳-前端基建方向/","link":"","permalink":"http://example.com/2022/undefined/21/%F0%9F%97%B3%F0%9F%97%B3-%E5%89%8D%E7%AB%AF%E5%9F%BA%E5%BB%BA%E6%96%B9%E5%90%91/","excerpt":"","text":"为什么搞前端基建？在业务开发中，解决普遍性、高频性的工作，让业务开发更幸福。 怎么搞？前端基建的几个方向 1.CLI套件，脚手架最佳实践基本稍微成熟的团队，都会有自己的cli工具，快速开发，拉取，定义。例如海尔的packi，字节UED团队的Arco Design Pro吗，阿里的ice。最佳实践方案包括： 前端技术选型 UI模版 统一登陆 国际化 权限管理 菜单配置 路由配置 本地 Mock 数据 theme更改 数据请求 Proxy方案 状态管理 日志打印 环境配置 文件上传环境搭建 私有源搭建 2.端数据监控端性能跟踪分析，行为数据监控，埋点反馈。端性能检测包括： 首开速度 图片大小检测，预加载 tcp速度 dns解析速度 gzip是否开启等 3.端构建发布发布构建，主要解决两大问题： 资源发布 版本号管理，回溯 成熟的方案如jekins，gitlab-cli，可在此基础上开发或者按照自己的具体需求定制，例如政采云的云长系统，插件化定制，例如构建检测中断，具体如API兼容，debugger关键词检测，包版本监控。 4.可视化搭建解放开发，非开发人员可自动定制，如采购平台首页，定制楼层，商品。 5.特色场景自动化工具，各个领域工具链特别工具解决特别场景问题。例如：swagger Api查找工具，python开发商品自动发布工具，webpack-afteremit-zipfloder-plugin插件，移动端pc调试工具 6.前端规范，文档规范方面：代码规范，命名规范，git分支管理、提交规范，lint标准。文档方面：代码未动，文档先行，目前现有的文档站点方案有 docsify、gitbook、vuepress 等，也可以自己DIY。 7.端安全防护 代码兼容性检测 包安全检查 恶意请求拦截报警 端构建发布跟踪 接口请求报错 代码回滚指派 统计静态资源加载问题 如何做前端基建人前端人员不应把自己设限在前端的UI层。着眼于服务层，网管层，Java，go，nodejs,，mysql，redis，前端不止于前端。 仰望星空，基建的未来 前端基建应该和公司具体发展阶段相吻合： 初期团队前端要求能用就行，拼人力完全能搞定； 发展阶段如果业务增值10倍，团队也要增长10倍？靠加班996方式拼蛮力，老板费钱，我不幸福。把当前业务努力做好，等业务相对成熟，就得进入想办法阶段，梳理工具链，工具化，系统化，降低人肉要求。 成熟阶段经过中期发展阶段，基建相对完善，人工智能方向突破；如阿里鲁班制图，微软sketch2json，京东Deco，设计稿直接生成代码，更多是探索 AI 与前端结合的各种可能性。 前端文档站点搭建方案前端搞基建|Scott - 如何在人单力薄时立项推动基建","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎨🎨git-The-project-you-were-looking-for-could-not-be-found-解","slug":"🎨🎨git-The-project-you-were-looking-for-could-not-be-found-解","date":"2022-05-15T16:00:00.000Z","updated":"2022-06-10T01:04:40.236Z","comments":true,"path":"2022/undefined/15/🎨🎨git-The-project-you-were-looking-for-could-not-be-found-解/","link":"","permalink":"http://example.com/2022/undefined/15/%F0%9F%8E%A8%F0%9F%8E%A8git-The-project-you-were-looking-for-could-not-be-found-%E8%A7%A3/","excerpt":"","text":"问题描述：使用git clone项目，出现The project you were looking for could not be found 原因：git自动保存了用户名密码，当前项目的用户名密码与之前的发生冲突。很有可能是github设置了用户名和密码，当你在别的平台使用git时用户名就不一样了，发生错误 解决方案：（1)一次性 1git clone http://mygitusername@git.coding.net/name/project.git （2）永久 windows: 清除本地git账户，重新输入用户名与密码。 1git config --system --unset credential.helper 之后再进行git操作时，弹出用户名密码窗口，输入即可。 mac: 1git config --global credential.username &lt;mygitusername&gt; Git密码（登录凭证）的保存和重置 Mac","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🐓🥚docker打包node-js服务","slug":"🐓🥚docker打包node-js服务","date":"2022-05-14T16:00:00.000Z","updated":"2022-06-10T01:04:40.094Z","comments":true,"path":"2022/undefined/14/🐓🥚docker打包node-js服务/","link":"","permalink":"http://example.com/2022/undefined/14/%F0%9F%90%93%F0%9F%A5%9Adocker%E6%89%93%E5%8C%85node-js%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"背景：把node.js服务放在linux上，每次都要搞一堆配置。 解决方法：使用docker打包有当前node 项目，向前端展示某个文件下的文件app.js 展示文件列表的小软件 12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;);const app = express();const fs = require(&#x27;fs&#x27;);app.use(express.static(&#x27;public&#x27;));const path = require(&#x27;path&#x27;);let rootPath = path.resolve(__dirname, &#x27;./public&#x27;);app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.sendFile(`$&#123;__dirname&#125;/index.html`);&#125;);app.get(&#x27;/file/getList&#x27;,(req,res,next) =&gt; &#123; var readDir = fs.readdirSync(rootPath); console.log(readDir); res.send(&#123; code: 200, data: readDir &#125;)&#125;)app.use(express.static(&#x27;public&#x27;)) .listen(3000); 安装dokcer:$ brew install --cask --appdir=/Applications docker 创建 Dockerfile 文件:touch Dockerfile 123456789101112FROM node:8-alpine # Create app directoryWORKDIR /appCOPY package.json app.js index.html ./COPY public ./public# Install app dependenciesRUN npm installCMD [&quot;npm&quot;, &quot;start&quot;] 构建docker镜像docker build . -t chenxiaobei/node-alpineps: 镜像名&#x2F;前是docker hub你的用户名 查看docker内文件是否完整docker run -it --entrypoint sh chenxiaobei/node-alpine 运行docker镜像 docker run -p 3000:3000 -d chenxiaobei/node-alpine 发布镜像docker push chenxiaobei/node-alpine在https://hub.docker.com/上查看 linux安装dockercurl -sSL https://get.daocloud.io/docker | sh linux启动dockersystemctl start docker 服务器拉取镜像docker pull chenxiaobei/node-alpine 服务器运行镜像docker run -dit -p 3000:3000 chenxiaobei/node-alpine","categories":[],"tags":[{"name":"实践堂","slug":"实践堂","permalink":"http://example.com/tags/%E5%AE%9E%E8%B7%B5%E5%A0%82/"}]},{"title":"🌦🌦webpack&esbuild---两者可以兼得","slug":"🌦🌦webpack&esbuild---两者可以兼得","date":"2022-05-11T16:00:00.000Z","updated":"2022-06-10T01:04:40.236Z","comments":true,"path":"2022/undefined/11/🌦🌦webpack&esbuild---两者可以兼得/","link":"","permalink":"http://example.com/2022/undefined/11/%F0%9F%8C%A6%F0%9F%8C%A6webpack&esbuild---%E4%B8%A4%E8%80%85%E5%8F%AF%E4%BB%A5%E5%85%BC%E5%BE%97/","excerpt":"","text":"esbuild打包速度碾压webpack,其优势我在另一篇文章中写过，请见为什么esbuild更快 下面介绍将webpack和esbuild结合的工具: esbuild-loader install$ npm i -D esbuild-loader Quick Setup 1234567891011121314151617181920 module.exports = &#123; module: &#123; rules: [- &#123;- test: /\\.js$/,- use: &#x27;babel-loader&#x27;,- &#125;,+ &#123;+ test: /\\.js$/,+ loader: &#x27;esbuild-loader&#x27;,+ options: &#123;+ loader: &#x27;jsx&#x27;, // Remove this if you&#x27;re not using JSX+ target: &#x27;es2015&#x27; // Syntax to compile to (see options below for possible values)+ &#125;+ &#125;, ... ], &#125;, &#125; 原理1.esbulder-loader 调用 esbulid 去打包js 代码。2.esbuild是go写的，可以打包成二进制文件，不用再安装go相关环境。 速度对比Before:After: 结论：速度快了1&#x2F;3左右，esbuilder-loader只能取代babal-loader的左右，像png,css等资源无法提供支持。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"☀️☀️UI开发的几个历史阶段","slug":"☀️☀️UI开发的几个历史阶段","date":"2022-05-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.235Z","comments":true,"path":"2022/undefined/10/☀️☀️UI开发的几个历史阶段/","link":"","permalink":"http://example.com/2022/undefined/10/%E2%98%80%EF%B8%8F%E2%98%80%EF%B8%8FUI%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%86%E5%8F%B2%E9%98%B6%E6%AE%B5/","excerpt":"","text":"1.过程化绘制时代 - 直接调用 drawLine &#x2F; drawRect 风格的 API 来绘制像素。在我的树莓派里，只要 include X11 的头文件，就能用 C 语言体验这种硬派的 GUI 开发了。HTML5 中的 Canvas，其实也属于这种风格。 2.面向对象抽象时代 - 纯粹过程化的代码，并不利于维护事件驱动的业务逻辑。比如，你需要自行计算来判断出某次点击应该选中哪个 UI 元素。在 MFC 和 GTK 的时代，人们实现了面向对象风格的 UI 框架。按钮、输入框等 UI 控件具备了实例方法，能更好地组织代码。 3.界面与样式分离时代 - 用 C++ 系语言的代码来描述 UI，很容易写出面条式的丑陋代码。因此人们又引入了 XML 风格的语言，专门来表达嵌套式的界面。DirectUI 和 HTML &#x2F; CSS &#x2F; JS 基础上的经典 Web，都是这个时代的产物。 4.MVC 与 MVVM 时代 - 如何维护日益复杂的 UI 交互逻辑？许多框架引入了软件工程中的 MVC 和 MVVM 等设计模式。这个时代的代表产物有苹果的 Cocoa 和微软的 WPF，以及 Web 上的 Angular 1 框架。 5.声明式组件化时代 - 为什么我们必须编写连接 UI 布局语言和业务逻辑的面条代码呢？Facebook 的 React 提出了新的 UI 开发思路。通过 JSX，很容易用 JS 来编写嵌套的、声明式的、更易维护的 UI 组件，并借助 JavaScript 的动态性来实时调试 UI。当前风口上的 Vue，Flutter 和 SwiftUI，都明显地借鉴了这种思想。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦js前后端数字返回不一致","slug":"🌦🌦js前后端数字返回不一致","date":"2022-03-31T16:00:00.000Z","updated":"2022-06-10T01:04:40.235Z","comments":true,"path":"2022/undefined/31/🌦🌦js前后端数字返回不一致/","link":"","permalink":"http://example.com/2022/undefined/31/%F0%9F%8C%A6%F0%9F%8C%A6js%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E5%AD%97%E8%BF%94%E5%9B%9E%E4%B8%8D%E4%B8%80%E8%87%B4/","excerpt":"","text":"场景：后端向前端通过一个接口返回一系列商品ID，前端通过商品ID去获取商品信息。问题：前端请求，但是没有这个商品的信息原因：后端返回的商品ID ，和前端获取的不一致，js数字采用64位双浮点数。范围 -(2^53 ) &lt;&#x3D; number &lt;&#x3D; 2^53所以当后端返回数字不在这一区间时，前端会丢失。比如：解决方法：后端转成字符串。 总结：js 简单弱类语言，这是设计不严谨的地方，导致很多混乱， Javascript的10个设计缺陷C语言中关于float、double、long double精度及数值范围理解 Number.MAX_SAFE_INTEGER","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦前端文件断点续传","slug":"🌦🌦前端文件断点续传","date":"2022-03-23T16:00:00.000Z","updated":"2022-06-10T01:04:40.234Z","comments":true,"path":"2022/undefined/23/🌦🌦前端文件断点续传/","link":"","permalink":"http://example.com/2022/undefined/23/%F0%9F%8C%A6%F0%9F%8C%A6%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/","excerpt":"","text":"","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦜🦜Vuex-Action异步执行使用场景","slug":"🦜🦜Vuex-Action异步执行使用场景","date":"2022-03-21T16:00:00.000Z","updated":"2022-06-10T01:04:40.234Z","comments":true,"path":"2022/undefined/21/🦜🦜Vuex-Action异步执行使用场景/","link":"","permalink":"http://example.com/2022/undefined/21/%F0%9F%A6%9C%F0%9F%A6%9CVuex-Action%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"vuex action 是全局事件触发的执行函数，定义 123456789101112const actions = &#123; login(state) &#123; axios(&#x27;login&#x27;).then(res =&#123; state.login = true &#125;) &#125;&#125;// 执行this.dispatch(&quot;login&quot;).then(res =&gt; &#123; &#125;) 相交于一般 muitition具有异步执行的功能😺,具体是包了一层Promise.resolve,其实完全可以用muitition,commit实现，只要return new Promise 123456789101112const mutations = &#123; login (state) &#123; return new Promise(resolve =&gt; &#123; axios(&#x27;login&#x27;).then(res =&#123; resolve(res) state.login = true &#125;) &#125;) &#125; &#125;// 执行this.$store.commit(&quot;login&quot;).then(res =&gt; &#123;&#125;)","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"☀️☀️单例模式","slug":"☀️☀️单例模式","date":"2022-03-19T16:00:00.000Z","updated":"2022-06-10T01:04:40.243Z","comments":true,"path":"2022/undefined/19/☀️☀️单例模式/","link":"","permalink":"http://example.com/2022/undefined/19/%E2%98%80%EF%B8%8F%E2%98%80%EF%B8%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式使用 VuexVuex基本原理，在vue上挂一个store属性，所以这个store属性一定要单一，而且不能被覆盖掉。Vuex 是vue 状态管理工具，如果在一个项目里有多个store,一定乱套了，所以Vuex一定是单例模式的。 Vuex单例模式实现方式 12345678910111213let Vue // bind on installexport function install (_Vue) &#123; if (Vue &amp;&amp; _Vue === Vue) &#123; if (__DEV__) &#123; console.error( &#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27; ) &#125; return &#125; Vue = _Vue applyMixin(Vue)&#125; install的时候，把真Vue 赋值给 假Vue, 再次install的时候，就会提醒&#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;","categories":[],"tags":[{"name":"编程范式","slug":"编程范式","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"}]},{"title":"📣🐘🐘🐘🐘-程序员指东","slug":"📣🐘🐘🐘🐘-程序员指东","date":"2022-03-16T16:00:00.000Z","updated":"2022-06-10T01:04:40.233Z","comments":true,"path":"2022/undefined/16/📣🐘🐘🐘🐘-程序员指东/","link":"","permalink":"http://example.com/2022/undefined/16/%F0%9F%93%A3%F0%9F%90%98%F0%9F%90%98%F0%9F%90%98%F0%9F%90%98-%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8C%87%E4%B8%9C/","excerpt":"","text":"如何成为一个专业一点程序员软实力 1.文档写作能力“文档是第一生产力”，这一点在程序员的世界是毫无异议的。看看Spring，hibernate，Struts等最流行的开源软件的文档就知道，他们tutorial，他们的getstarted，他们的reference文档写的多么的易懂。如果要获得更高的报酬，文档是绝对关键的因素。有文档就有沟通，就有交易。搞技术的容易忽视文档的力量，也因为写文档十分困难，更多程序员选择舒适区，习惯写下代码，但正因为如此，妨碍了不少程序员的进阶。 2、清晰的表达能力表达能力决定了你所做的技术的影响范围，决定了你的影响力，决定你的威信，决定了你的报酬。普通程序员和顶尖程序员的表达能力差别非常大，这主要还是取决于他们格局的不同。良好的沟通能力让你理解产品经理的设计思路，让你更好的展现自己的特长。 3、英语水平是的，英语很重要，除了看日常工程文档外，作为计算机发源地母语，精英荟萃，各路高手都是通过英语交流，虽然中国是仅此于美国的互联网大国，如果你希望碰到更多不同的人，看到更多的风景，学习英语可以打开另一个世界 硬实力 1、优雅和美观的抽象能力，追求代码世界的简约普通程序员和顶尖程序员之间的区别在于优雅和美观的抽象能力。好的系统通常是要做到两个方面才合格，其一是好用，其二是好看。但是令人遗憾的是，普通程序员仅仅从实现的角度进行堆砌。顶尖程序员往往能够更进一步，经常会去思考用户在操作这个功能的时候，到底还会做什么事情。 代码的注释是否恰到好处、函数模块和类的结构是否能让其他人直接秒懂、架构的设计是否足够清晰等等，都属于程序员追求简约的范畴。有一种炫技程序员或者架构师，喜欢简单事情往复杂了做。明明几个类能搞定的，弄出很多中间类，明明三层架构就解决的问题，生生弄出五层。 2、裸编能力处理程序实际实现部分的子任务，实现函数或者算法之类的能力。听起来很简单对吧？实际上很多程序员缺失这样的能力。不知道大家有没有见过「复制粘贴工程师」，review他们的代码甚至会发现一些网上的注释，又或者其他人的编写错误。 3、掌握底层系统原理处理复杂任务或解决复杂BUG时，具备深厚的底层系统知识非常重要。比如数据结构、网络协议、操作系统相关知识，等等。程序的很多问题都是源于对计算机工作原理的误解，即使是使用高级语言开发的程序也一样。另外，一些更偏应用层的架构或框架，基础一定是更底层的系统。了解了底层原理，我们才能看穿眼花缭乱的技术背后的东西，不被层出不穷的新技术所累。 4.算法能力普通的程序员连时间复杂度怎么计算可能都不清楚，优秀的程序员轻松用算法优化性能卡点，更别提大厂面试普遍要求手写算法。程序员要想进大厂先从刷算法做起是个好方法，算法厉害的人进大厂非常容易。 核心能力作为搞计算机的同学，抽象能力是核心能力，加油。 能力拆分，程序员象限 1.认知态度人的一生，失败和挫折可能是主流，会伴随我们的一生。成功就是在失败的基础上一点一点积累起来的。 我们一定要认真，一定要自信，一定要踏实。 踏实程度，左耳朵耗子曾说： 对于当前这个社会：大多数人的信息渠道都被微信朋友圈、微博、知乎、今日头条、抖音占据着。这些信息渠道中有营养的信息少之又少。大多数公司都是实行类似于 996 这样的加班文化，在透支和消耗着下一代年轻人，让他们成长不起来。因为国内互联网访问不通畅，加上英文水平受限，所以，大多数人根本没法获取到国外的第一手信息。快餐文化盛行，绝大多数人都急于速成，心态比较浮燥，对事物不求甚解。所以，你看，在这种环境下，你根本不需要努力的。你只需要踏实一点，像以前那样看书，看英文资料，你只需要正常学习，根本不用努力，就可以超过你身边的绝大多数人。 积极性，任正非内部讲话第一篇：价值观态度比能力重要，态度决定高度。总之注意非智力因素的培养，非技巧因素培养，韧劲，毅力，坚持，需要引起重视。一步一个脚印的往前走。 2.个人素质个人素质很重要，就是智商了，有些东西确实需要智商，比如这个人是否够聪明，学习能力快。这个天生的没办法，多吃核桃吧。 3.理论积累和高度这是区分理论研究和应用研究的一个重要分水岭。理论达到当前领域的纬度，可以孵化出不同的应用方向。比如拥有深厚理论功底的计算机博士，可以在智能驾驶，图像人脸检测，大数据，机器人等开辟新的方向。而这些东西让一个没有理论知识只知道搞api得应用开发者，是搞不成的。 结论就是：理论高度决定了你的工作领域的高度。 基础是否牢靠，计算机原理，数据结构算法，思维逻辑清晰，也可以叫内功，少林有72绝技，但是让它成为武林泰斗的还是《易筋经》，这个东西，需要自己磨练，靠项目无法提升，多看书，多刷题，多消化。有机会搞个更高的学位，比如考研，考博。 4.应用经验积累计算机应用一直在变化，应用领域一直在变化，可能有些专业知识，过几年就没市场了，领域没了，开发经验就是废纸，比如正在下沉的安卓，IOS，但同样重要。。 1.应用专业知识积累不断完善系统化知识，知识地图。比如你是前端 css js。。 ,后端java 数据库。。。 2.工程化积累是否在工作中一直积累有效经验，注意是有效经验，一年经验用N年的程序员一抓一大把。不要以调用API作为一种项目积累，这东西几天不用，就快忘干净了。有效积累绝不是记住和调用APi；主要是在某种语言和设计模式方面有了基础的积累，对软件设计的场景积累，工程化解决方案的方向。 怎么样写出自己JSSDK,具有项目创造力呢？以下是我的一位前辈说的: 我个人觉得，或者说我的方法一般都是早期临摹就跟写书法一样。我一般回去bestofjs去寻找比较热度适中的库来临摹。为什么呢？因为一般热度适中的库的代码复杂度不是很高，但是整体代码质量也还可以，能够看懂并模仿下来。然后我一般是看懂了，关上他的。自己开始着手去做，遇到问题了再回去参考人家的。直到跑通代码、我再去看那些这个项目下的其他特别火热的库。大家会觉得？为啥不直接临摹最火热的。因为这种一般经过长时间维护代码复杂度太高了，就比如蹦台阶，不可能一下能到10层20层，先蹦到2层，4层。等我的代码跑起来我再从他的代码和项目结构中吸收精髓。这样下来下几个库你就会有创造的能力。最后就是多学习一些技巧语法，比如devto啊、大牛的推特啊。都能让你的编码技术大增。 参考： 《深入理解计算机系统》","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📣🚶🚶🚶🏻千万不要被别人打乱自己的节奏","slug":"📣🚶🚶🚶🏻千万不要被别人打乱自己的节奏","date":"2022-03-16T16:00:00.000Z","updated":"2022-06-10T01:04:40.233Z","comments":true,"path":"2022/undefined/16/📣🚶🚶🚶🏻千万不要被别人打乱自己的节奏/","link":"","permalink":"http://example.com/2022/undefined/16/%F0%9F%93%A3%F0%9F%9A%B6%F0%9F%9A%B6%F0%9F%9A%B6%F0%9F%8F%BB%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E8%A2%AB%E5%88%AB%E4%BA%BA%E6%89%93%E4%B9%B1%E8%87%AA%E5%B7%B1%E7%9A%84%E8%8A%82%E5%A5%8F/","excerpt":"","text":"最近看了一个小视频，话说韩国的一位拳击选手，沈健吾对阵美国名将“抱抱熊”巴内特，赛前的称重环节，突然从包里掏出一束花，向举牌女郎表白，这个举牌女郎正是韩国知名模特李恩慧，而李恩慧则在社交平台表示，如果沈健吾能够赢得这场比赛，就答应做他的女朋友。 比赛开始环节，沈健吾为了抱的美人归，急于求胜，被巴内特，几个下踢，打乱节奏。比赛中期，沈健吾看似进攻其实没有任何节奏，越来约虚弱。比赛后期，沈健吾急于表现自己，不断向前压制，被巴内特一个后摆KO感觉沈健吾压力很大，俗话说心机则乱，最终被巴内特一个后摆ko倒地。 如果沈健吾不是这么急于表现自己，为自己搞这么大的flag，他不一定赢，但是一定不会输这么惨。节奏乱了，步调就乱了，工作和生活都乱了，整个人生就乱了。混乱的节奏不仅带来了生活的低质量和工作的低效率，还带来了无尽的烦恼和压力。 别为自己挖坑,把握好自己的节奏，不要被别糖衣炮弹打乱自己的节奏，不要被当前快节奏生活裹挟。可能我们有时跑的太快了，停下来，等一等灵魂吧。 ·秀恩爱，死的快","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-for-循环异步执行-异常处理","slug":"🌦🌦-for-循环异步执行-异常处理","date":"2022-03-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.232Z","comments":true,"path":"2022/undefined/10/🌦🌦-for-循环异步执行-异常处理/","link":"","permalink":"http://example.com/2022/undefined/10/%F0%9F%8C%A6%F0%9F%8C%A6-for-%E5%BE%AA%E7%8E%AF%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"有个需求是循环请求一个接口获得数据，问题是循环请求了但是接口是异步的，按顺序传过去的返回来的并不一定按顺序返回来。 解法一：async await1234567891011121314151617181920mounted() &#123; this.queryNewFund(); &#125;, methods: &#123; async queryNewFund() &#123; let that = this; let codeList = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; for (let i = 0; i &lt; codeList.length; i++) &#123; let obj = await that.getData(codeList[i]); console.log(obj); &#125; &#125;, getData(id) &#123; return new Promise(resolve =&gt; &#123; axios.get(id).then(result =&gt; &#123; resolve(result); &#125;); &#125;); &#125; &#125;, 解法二：Promise.all利用Promise.all 顺序返回的特性 12345678910111213141516171819202122mounted() &#123; this.queryNewFund(); &#125;, methods: &#123; async queryNewFund() &#123; let that = this; let codeList = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; for (let i = 0; i &lt; codeList.length; i++) &#123; this.asyncLists.push(this.getData(codeList[i])) &#125; Promise.all(this.asyncLists).then((res) =&gt; &#123; // 四个result 结果 顺序返回 &#125;) &#125;, getData(id) &#123; return new Promise(resolve =&gt; &#123; axios.get(id).then(result =&gt; &#123; resolve(result); &#125;); &#125;); &#125; &#125;, 解法三 :promise 递归12345678910111213141516171819202122mounted() &#123; this.queryNewFund(); &#125;, methods: &#123; queryNewFund() &#123; let that = this; let codeList = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; this.getData(codeList, 0); &#125;, getData(codeList,index) &#123; if (i === codeList.length) &#123; return; &#125; new Promise(resolve =&gt; &#123; axios.get(codeList[index]).then(result =&gt; &#123; resolve(result); &#125;); &#125;).then(res =&gt; &#123; this.getData(codeList,index + 1); &#125;); &#125; &#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📣🤔🤔-关于技术和创业的思考","slug":"📣🤔🤔-关于技术和创业的思考","date":"2022-02-27T16:00:00.000Z","updated":"2022-06-10T01:04:40.232Z","comments":true,"path":"2022/undefined/27/📣🤔🤔-关于技术和创业的思考/","link":"","permalink":"http://example.com/2022/undefined/27/%F0%9F%93%A3%F0%9F%A4%94%F0%9F%A4%94-%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E5%92%8C%E5%88%9B%E4%B8%9A%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"怎样看待技术最近，身边的小伙伴很多都开始自主创业，我不进有点浮想联翩。 技术对社会进步具有重要推动作用，这句话的范畴是技术的大规模应用。如果某项技术在某个时间段没有被某个人发明，难道这项技术就不回存在了吗？ 没有爱因斯坦，核武器就不会出现？没有乔布斯，智能手机就不会出现？没有牛顿，万有引力就没人发现？ 我觉得就算当时没有出现，以后也会有别的人去发现。 搞技术被替代的可能性非常高，因为很多都是已知的，具体的，不像创业需要冒险，所谓高风险高收入。技术入门门槛没有那么的高，IT技术到今天基本原理并没有变化，仍旧是冯诺伊曼体系，数据结构和算法几十年也不会变。 另一方面，语言在发展，框架在更新，两年不学习，可能行业就不存在了，你怎么证明你曾经的经验呢，这个行业的特点就是日新月异，很难有所积累，人脉无法积累，经验无法积累。 积累型工种怎么区分呢？总分为两种类型：1、资源积累型，比如销售，餐饮业；2、经验积累型，比如医生、教师，会计。 老师年纪越大越吃香，因为教材不会经常变。律师年纪越大越吃香，因为法律条文不会朝令夕改。医生年纪越大越吃香，因为人的生理结构不会变。文物鉴定师年纪越大越吃香，上百年的文物不会变吧。 希望在一个技能行业耕耘的前提是，这个行业知识体系结构不会有激进性，高频率的改变。技术能创造的价值是有限的，有限到我们常常高估自己，高估这个行业对社会进步的影响。 改变世界的是人和点子，让你被更多人被需要，而不是技术。通过阿里搞死的虾米，天天动听，总结人还是应该做自己感兴趣和熟悉的事，起码你要认可你在做的事情，热爱着它。总拿着功利主义去做事，你做不好的。 关于人生目标成为高级程序员，大牛工程师是人生的一个方向，但绝不是最高目标。技术不能应用到产品中，就是一页废纸，把产品和技术结合起来，运用到商业层面。正如雷军所言：无论多么高级的程序员，关键是你能否出想法出产品，你的劳动能否被社会承认，为社会创造财富，成为高级程序员绝对不是追求的目标。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📁📁-关闭linux系统端口","slug":"📁📁-关闭linux系统端口","date":"2022-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.231Z","comments":true,"path":"2022/undefined/10/📁📁-关闭linux系统端口/","link":"","permalink":"http://example.com/2022/undefined/10/%F0%9F%93%81%F0%9F%93%81-%E5%85%B3%E9%97%ADlinux%E7%B3%BB%E7%BB%9F%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"通过进程名1、先查看进程pidps -ef | grep 进程名 2、通过pid查看占用端口netstat -nap | grep 进程pid 3.杀掉进程kill -9 PID lsof : 通过端口号lsof(list open files)是一个列出当前系统打开文件的工具。 1、查询8080端口是否被占用，并可以查看pid&#x2F;程序名netstat -apn | grep 8080 2、查看详细信息ps -ef | grep PID 3、终止该进程 kill -9 PID","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🗳🗳-nginx配置静态文件和代理服务","slug":"🗳🗳-nginx配置静态文件和代理服务","date":"2022-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.231Z","comments":true,"path":"2022/undefined/10/🗳🗳-nginx配置静态文件和代理服务/","link":"","permalink":"http://example.com/2022/undefined/10/%F0%9F%97%B3%F0%9F%97%B3-nginx%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%92%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"需要把前后端分离的项目部署到服务器,前端静态资源通过nginx代理访问,接口请求代理到指定端口的服务上,先看配置: 12345678910111213server &#123; listen 4040; server_name 127.0.0.1; location / &#123; root /opt/demo/static; index index.html index.htm; &#125; location /api &#123; proxy_pass http://example.com:4041/; &#125;&#125; nginx代理端口4040, 后台服务端口4041. 这个要注意了,nginx监听的端口不能与服务端口相同1./根目录 –被代理到–&gt; /opt/demo/static路径下那么在static下的静态资源就可以直接被访问了,形式: http://127.0.0.1:4040/index.html 2.以api开头的请求–被代理到–&gt;4041端口比如：http://127.0.0.1:4040/api/test被代理到–&gt; http://example.com:4041/api/test pack脚手架nginx项目配置，生产环境12345678resolver 10.138.92.77;location ^~ / &#123; set $entry index.html; set $prefix http://cdn.haier.net/assets/overlay/dts-fe/html-entries-prod; set $project_name &lt;项目名&gt;; proxy_pass $prefix/$project_name/$entry;&#125; 线上完整版配置 123456789101112131415161718192021222324252627282930313233343536user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; client_max_body_size 20M; include /etc/nginx/default.d/*.conf; resolver 10.138.92.77; location ^~ / &#123; set $entry index.html; set $prefix http://cdn.haier.net/assets/overlay/dts-fe/html-entries-prod; # 下面一行填写GitLab项目地址 set $project_name myproject; proxy_pass $prefix/$project_name/$entry; &#125; &#125;&#125; [1] https://www.cnblogs.com/linyufeng/p/13361640.html[2] https://www.jianshu.com/p/b010c9302cd0","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌈-解决flex布局warp自动换行下最后一行居中问题","slug":"🌈-解决flex布局warp自动换行下最后一行居中问题","date":"2022-01-09T16:00:00.000Z","updated":"2022-06-10T01:04:40.230Z","comments":true,"path":"2022/undefined/09/🌈-解决flex布局warp自动换行下最后一行居中问题/","link":"","permalink":"http://example.com/2022/undefined/09/%F0%9F%8C%88-%E8%A7%A3%E5%86%B3flex%E5%B8%83%E5%B1%80warp%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%E4%B8%8B%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/","excerpt":"","text":"现象：这是一段很简单的flex弹性布局代码： 1234567891011121314151617181920212223242526272829303132HTML: &lt;div&gt; &lt;div class=&quot;flex-test&quot;&gt; &lt;div class=&quot;box-test&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;8&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;CSS这边是这样：&lt;style&gt;.flex-test &#123; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: start; background: blue;&#125;.box-test &#123; height: 100px; width: 100px; background: red; margin: 10px;&#125;&lt;/style&gt; justify-content: start 的时候，结果是这样的： 现在，我们需要将所有红色格子整体居中，很简单：将 justify-content: start 改成：justify-content: center 就行了，结果如下：嗯，OK ! 是我们想要的效果！接下来，将可视宽度收窄（比如在手机上显示），变成了这样： 纳尼？怎么变成这个鬼样子了？flex 布局下，warp之后自动换行，换行后的内容又被居中了。这不太符合一般的排版规则，看起来怪怪的不是吗？ 解决搜了很多资料，发现这个问题还不怎么好解决，算是 flex 弹性布局的一个缺陷吧，如果要最后一行与第一行对齐，我们只能将 justify-content 设为 start, 但这样一来就失去了居中的效果。屏幕右边会空出一截来。但是，为了居中，我们将 justify-content 设为 center后，最后一行又非常别扭地立在屏幕正中，也很突兀。 解决方案是换用grid布局： 12345678910111213141516171819202122232425262728HTML: &lt;div class=&quot;grid-test&quot;&gt; &lt;div class=&quot;box-test&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;box-test&quot;&gt;8&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;CSS:.grid-test &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px); grid-gap: 10px; justify-content: center; background: blue;&#125;.box-test &#123; height: 100px; width: 100px; background: red; margin: 10px;&#125; 换用以上代码后，显示如下：","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎅-🎁--为什么esbuild更快","slug":"🎅-🎁--为什么esbuild更快","date":"2021-12-25T16:00:00.000Z","updated":"2022-06-10T01:04:40.230Z","comments":true,"path":"2021/undefined/25/🎅-🎁--为什么esbuild更快/","link":"","permalink":"http://example.com/2021/undefined/25/%F0%9F%8E%85-%F0%9F%8E%81--%E4%B8%BA%E4%BB%80%E4%B9%88esbuild%E6%9B%B4%E5%BF%AB/","excerpt":"","text":"1.使用Go语言,编译成原生代码很多打包工具是用js写的，但是命令行工具对于JIT编译语言是在性能方面最拉垮。每次打包，js编译器都会把代码当作第一次运行，没有任何优化。当esbuild忙着解析你的js,node忙着解析你的打包工具的js。当node完成包代码解析，esbuild已经可能已经退出了，而你的打包工具甚至还没有开始。 另外，Go被设计成并行的，但js不是。Go的线程之间共享内存，然而js在线程之间序列化数据。Go和js都有并行的垃圾收集器。但是在Go的堆在线程间是共享的，然而js每个线程都有独立的堆。根据我的测试，这似乎将 JavaScript 工作线程可能的并行量减少了一半，大概是因为你的 CPU 核心的一半正忙于为另一半收集垃圾。 2.并行性被大量使用esbuild内部算法经过精心设计，以在可能的情况下使所有可用的 CPU 内核完全饱和。有三个解析阶段：解析，链接，生成代码。解析和生成代码是主要工作，并行性强(链接在很大程度上是一项固有的串行任务)。因为所有的线程共享内存，在导入相同的js库时候，功能可以在不同的点共享。现在很多电脑都是多核的，所有并行是一项很大的胜利。 3.esbuild 中的一切都是从头开始编写的自己写代码而不是使用第三方库，有很多性能优势。您可以从一开始就考虑性能，确保所有的东西都使用了相同的数据结构，这样可以避免昂贵的转换。并且您可以在必要时进行广泛的架构更改，缺点当然是工作量很大。比如很多打包工具使用官方的TS编译器作为解析器。但是这是为TS编译器团队的目标服务的，他们没有将性能作为重中之重。他们的代码大量使用了巨型对象形状和不必要的动态属性访问(这两个都是众所周知的 JavaScript 减速带)。即使类型检查被禁用，TypeScript 解析器似乎仍然运行类型检查器。这些问题， esbuild 的自定义 TS 解析器都没有。 4.内存高效利用理想情况下，编译器的输入长度主要为 O(n) 复杂度。因此，如果您正在处理大量数据，内存访问速度可能会严重影响性能。数据传输的越少（并且将数据转换成的不同表示形式也越少），编译器运行的越快(好像是废话)。 比如，esbuild只会接触整个js的AST数三次1.第一次是词法，全局安装，声明变量2.第二次是构建变量，。。这一部分不会翻译，剩下的2023年再写。。 5.内存数据紧凑可以在内存里紧凑的存储数据，这一点可以使用更少的内存，更适合CPU缓存。所有的对象字段都有类型，而且字段被紧凑的打包在一起。例如，几个布尔标志每个只占用一个字节。Go也有值语义，可以将一个对象直接嵌入到另一个对象中，这样它就“免费”而无需另一个分配。js没有这些特性，而且还有其他特点，比如JIT开销(比如，隐藏类槽)，低效的声明(比如非整数用指针分配在堆上）。 这些因素中的每一个都只是略微显着的加速，但是放在一起就比今天常用的打包器快几个数量级。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-下载文件两种方式总结","slug":"🌦🌦-下载文件两种方式总结","date":"2021-12-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.227Z","comments":true,"path":"2021/undefined/24/🌦🌦-下载文件两种方式总结/","link":"","permalink":"http://example.com/2021/undefined/24/%F0%9F%8C%A6%F0%9F%8C%A6-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.后台服务器有静态资源且是固定的文件名（GET方式下载文件）场景：已经生成的静态文件 使用js1window.location.href=&quot;http://www.域名/template.xlsx(文件名)&quot; html1&lt;a href=&quot;http://www.域名/template.xlsx(文件名)&quot;&gt;&lt;/a&gt; ps: 有跨域问题 2.后台返回文件流场景：动态数据生成 使用 FileReader123456789101112131415161718192021axios.post(请求路径URL, &#123;参数Params&#125;, &#123; responseType: &#x27;blob&#x27; &#125;).then(function(res)&#123; var blob = res.data; // FileReader主要用于将文件内容读入内存 var reader = new FileReader(); reader.readAsDataURL(blob); // onload当读取操作成功完成时调用 reader.onload = function(e) &#123; var a = document.createElement(&#x27;a&#x27;); // 获取文件名fileName var fileName = res.headers[&quot;content-disposition&quot;].split(&quot;=&quot;); fileName = fileName[fileName.length - 1]; fileName = fileName.replace(/&quot;/g, &quot;&quot;); a.download = fileName; a.href = e.target.result; document.body.appendChild(a); a.click(); document.body.removeChild(a); &#125; &#125;); 使用window.URL.createObjectURL123456789101112axios.post(请求路径URL, &#123;参数Params&#125;, &#123; responseType: &#x27;blob&#x27; &#125;).then(function(response)&#123; const name = &quot;XXX.xls&quot; const url = window.URL.createObjectURL(new Blob([response])); const link = document.createElement(&quot;a&quot;); link.href = url; link.download = name document.body.appendChild(link); link.click(); document.body.removeChild(link); &#125;); 动态数据下载，原理都是创建 blob协议的链接","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎨🎨-git-reset-三种模式","slug":"🎨🎨-git-reset-三种模式","date":"2021-12-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.229Z","comments":true,"path":"2021/undefined/24/🎨🎨-git-reset-三种模式/","link":"","permalink":"http://example.com/2021/undefined/24/%F0%9F%8E%A8%F0%9F%8E%A8-git-reset-%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"https://www.jianshu.com/p/c2ec5f06cf1a","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎅🏻🎅🏿-50个提高编码水平的方法","slug":"🎅🏻🎅🏿-50个提高编码水平的方法","date":"2021-12-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.228Z","comments":true,"path":"2021/undefined/24/🎅🏻🎅🏿-50个提高编码水平的方法/","link":"","permalink":"http://example.com/2021/undefined/24/%F0%9F%8E%85%F0%9F%8F%BB%F0%9F%8E%85%F0%9F%8F%BF-50%E4%B8%AA%E6%8F%90%E9%AB%98%E7%BC%96%E7%A0%81%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"我已经做了30多年的程序员了，程序员是一个终身学习，练习和提高的职业，在我的职业生涯中，我发现了很多方法来提高编码水平 提升程序员水平的50种方法 1.写大量程序，你写的每个程序不论大小，都会给你一些经验。练习可以提高你对编程概念的理解。 2.让编程变成你的爱好。开发个人项目可以创造热情和激情。如果你喜欢这样做，学习就很容易了。 3.在Stack Overflow上找答案。如果你有一个编程问题，很有可能会在Stack Overflow上找到答案。对答案保持批评态度，并把这个当作学习的机会。当你准备好的时候，也回答一下别人的问题。 4.读好书，完成里面的例子。好的编程书有体系化的内容可以学习， Deitel books里面有很多例子和解释，如果你是个新手，可以看看我的书: The Super Simple Programming Book。 5.学会一种方法，忽略其他方法，编程语言提供了不止一种方法去完成同一个任务，有几种方法可以将整型变量增加1。现在学习一种方法，然后你就可以学习其他编程概念了。 6.学习基础的编程概念，当你学习编程的时候，基础很重要。学习数据类型，输入输出，选择，复用，等等。注重基础概念，这些将有利于学习其他语言。 7.找一个导师，和有编程能力的人建立联系，从一个导师身上学到的远比你从网站和书上多的多。 8.参加编程赛事，编程赛事是练习编程水平的有趣方法。推特有#100DaysOfCode.Code.org 有 Hour of Code.The Advent of Code真的是一个很有趣的编程挑战在11月的前25日。线上有更大赛事。 9.参加一个免费的学习课程，Coursera有很多来自顶级大学的优秀计算机课程。在Udemy.上有很多相似课程。MIT OpenCourseWare出版了部分计算机科学课程的教材。 10.使用code linters，代码分析器为你的程序提供即时反馈。在线的w3c校验器可以校验你网页文档的合理性。ESlint帮你找到修复js中的合理性。Pylint可以校验Python 代码。Linters也可以在像vscode的IDE中当作插件使用，linters通过标记错误和建议性改变强迫你学习。 11.利用静态代码分析工具。SonarQube平台可以分析静态代码。可以帮你写出简洁，准确，安全的代码。 12.参与代码审查，包括作者和审查者。不要害怕代码审查，拥抱他们。我们都犯错误，错误是学习的绝好机会。 13.看油罐视频。上面有几乎所有多编程的教程，说明和课程。这些视频是学习编程的简单方法，仅仅通过看视频。比如，这里有一些关于Node.js的视频课程。 14.解决欧拉项目的问题。Project Euler有很多可以用代码解决的数学和电脑科学的问题。该网站列出了解决每个问题的人数。 15.参与谷歌代码大赛。Google coding competitions对于练习很有用，而且你不需要正式参加比赛。 Code jam是年度，世界性的代码比赛。它列举了过去和现在的问题。也可以看看Google kick和哈希码比赛。 16.使用IDE。集成开发环境，是可以帮你创造，编辑，debug程序的好工具。在你写代码的使用，IDES可以发现和高亮错误，给你正确的建议。IDE在你敲代码的时候给你集成性的代码参考。插件添加了额外的工具，如 linter 和查看器。现在最流行的IDE是 Visual Studio Code。 17.返回学校。如果你有条件，在当地的大学院或大学参与一个计算机课程，攻读计算机科学学士学位或认证，获得硕士学位将使您有资格在大学任教。 18.考虑参与一个编码训练营，编码训练营提供特定编程技能的专门培训。这些技能通常需求量很大，参与训练营一定要小心，他们通常不一样，而且大多数都很贵。 19.写技术博客。要学习一些东西，阅读它、听它和写它是有帮助的。在博客中写下您的日常编程经验将增强您的学习。让你有东西学更多的东西。两个流行的博客平台是Dev Community和 Hashnode，都是免费的博客平台，使您可以轻松地立即开始写博客。 20.通过在线教程工作，有很多优秀的在线编程教程，有些是为了阅读。其他都是互动的。W3Schools简单，互动，快捷的在线平台。Codecademy有很多不同语言的优秀互动课程。 21.参与编程论坛。阅读反馈博客。这些互动是非常好的学习机会。比如对java程序员来说，JavaRanch和Java Programming Forums是非常流行的java在线社区。 22.编程教学，教别人写代码，可以有效的提高你的编程知识，辅导大学或本地学生。为了去教别人，你必须备课，写例子，回答问题。这将迫使你理解编程，即使是志愿教授编程也有好处。 23.搞一个属于你的站点，如果你喜欢web开发，学习怎么开发你自己的网站。包括域名注册，托管和维护。像这样的个人项目给了很多学习和编码的动力。 24.参与代码面试。许多公司需要现场编码课程或带回家的作业作为面试过程的一部分，这些活动提供了非常好的学习机会和现实实践。你必须提前准备和学习。编码面试很有价值，即使你没有得到这份工作。 25.在开源项目中学习。开源项目站点，比如GitHub和GitLab提供了非常好的学习例子。其中许多软件项目在业界都很受欢迎，给这些项目做贡献提供了更多代码练习。 26.遵循编码标准、最佳实践和风格指南。代码标准和最佳实践改进代码。可以让代码更易读，更容易维护，更准确，谷歌为很多编程语言发布了代码标准和风格指南 。 PEP8 Online检查 Python 代码并建议最佳实践和指南。 27.成为自由职业者。把写代码当作服务。您可以在网上找到许多自由编程任务，即使一个好的练习机会也可以挣点钱。 28.参与技术社区，找到一个你所在领域的技术社区。在LinkedIn, Facebook, Meetup和其他站点有很多在线编程组。你可以和别人互动来分享你对技术的热忱。 29.找一份工作。找一份编程方面的工作，任何编程工作。没有什么比行业经验和学习更胜一筹了。 30.志愿写代码。每个行业都需要编程技术，很多行业没有能力雇佣程序员，有很多志愿编程的机会。在当地学校，俱乐部，组织有很多你可以提供帮助的编程任务。 Code.org可以匹配到所在领域的志愿编程机会。 31.写原生代码。是的。框架和库让写代码变得更简单，但是写原生代码可以学到很多东西。比如尝试用原生代码写js来代替jquery.使用纯数组代码java 数组类，写原生代码会迫使你考虑的更多，写更有效的方案。它还会让您领略许多有用的外部库的精华。 32.不要重复造轮子。对于重要的编程，不要重复造轮子。对于特殊编程任务和逻辑，寻找已存在的方案。这些方案已经被使用被测试。比如npm是在线的node库。PyPI托管外部Python库。选择编程库要挑剔一点，有些更好。 33.参与编程会议。编程会议将各个级别的开发人员聚集在一起进行演示、演示和其他学习机会。Grace Hopper Celebration是一个主要由女性参与的技术大会。Google I&#x2F;O是另一个开发者大会。还有很多编程会议。有些提供虚拟席位。如果不是，确保你在参加的时候，他们提供了合适的社交距离。 34.参与专业组织，像IEEE和ACM)这样的专业组织提供合作机会、期刊、会议、小组和其他学习机会。这样的组织是收费的，但是学生有折扣。 35.写一本书。对于编程书籍，主题无穷无尽。不论你现在编程水平如何，总有一本书适合你。像Amazon Kindle Direct Publishing这样的组织让出书变的更容易。写书，会迫使你真正的学习相关资料，创造实例，测试你的程序。 36.给机器人编程。有什么让编程进入你的生活更有趣呢。新手和专家可以搞一个机器人来完成编程任务。Sphero BOLT是具有传感器、运动和 LED 显示屏的可编程塑料球体。LEGO MINDSTORMS另一个具有高级技能的编程机器人。一些机器人在 Minecraft Education edition, Java Robocode, and Python turtle graphics等很有用。编程机器人让编程变得更有趣，因为它们可视化了您的程序输出。 37.访问Code.org. Code.org值得在这份名单上占有一席之地，该网站致力于学习、教学和推广计算机科学。有适合初学者的在线编码活动、编码统计、励志视频等。 38.尝试Alice。Alice是一个计算机科学的3D教学工具。可以让学校电脑科学可视化，趣味化。 39.学习使用git控制代码版本。虽然这和编程没有特别直接的联系，毫无疑问，您将使用 Git 来维护程序的版本。像GitHub, Bitbucket, and GitLab一类的在线git存储库都是很强大的软件协作工具，很多开发者使用GitHub托管代码。更多Git版本控制信息见Git website。 40.拥抱实时沟通。这是另一个不是和编程有直接关系的话题。实时沟通工具在你写代码时，提供及时反馈和答案。Slack是一个非常流行的实时沟通的工具，可以提供持久的文本、语音和视频聊天。这个工具允许你，为不同的主题创造公共的和私有的频道，它可以让您将对话串连起来，以便更有条理。 41.随时随地写代码。你的手机也是一台电脑，为什么不用呢， QPython是一个安卓手机的Python编译器，IOS上有Python2IDE，有了这样的App，你可以直接用你的手机写代码。 42.在没有帮助的条件下写代码。接受编程任务并编写程序，不上网搜索，不通过IDE的帮助。看看你是否可以通过记忆编程。这种类型的编码练习将迫使您牢记重要的概念。这对于现场编码也是很好的练习。 43.重构代码，学习怎么重构代码。即使程序为所有可能的输入产生正确的输出，仍有改进空间。比如，让你的程序更易维护，更易读，复杂度更低。 44.学习其它编程语言。一旦你对基础编程有了一个好的基础，对给定编程语言的深刻理解，你就可以另辟蹊径了。学习其他语言可以提高你对编程语言的总体理解。了解不同的语言如何实现相同的编程概念或提供新功能会很有帮助。例如，Java 编程语言通过解决内存泄漏对 C++ 进行了改进。 45.为艺术而编程。编程不仅仅是为了公司。编程可以创造艺术，通过随机行为、图形和处理，程序可以创建漂亮的输出。这将编程的热情提升到一个全新的水平。Python turtle graphics和 HTML Canvas 图形是用程序创建简单和复杂艺术的两种方法。 46.有一个正确的态度。要谦虚，你不可能知道编码的所有。即使你这样认为，我保证有人比你知道的更多。编程是没有尽头的循环。承认你不不知道，你很快就知道了。 47.利用公共 API。有很多公共的应用接口，你可以用在你的程序里。Twitter, YouTube, 和 Google Maps 有一些你可以再次开发的API。你可以在你的App中利用这些接口来创造骄人的应用。 48.用Soloway’s Rainfall problem评估你的编程水平。 Soloway’s Rainfall problem可以为计算机专业学生测试编程技能。如果你能晚上这些编程任务，你就对编程的基础有了一个很好的理解。如果没有，继续学习吧。 49.从控制台输入和输出中学习。即使有有精美的网站和图形用户界面。然而，不要忽略基础程序所提供的教学。接受来自 stdin 的输入并将输出写入 stdout 的程序可能非常强大、复杂且功能齐全。这些程序有很多东西可以学。 50.学习汇编语言，理解计算机架构。当一个程序执行时。它使用了计算机资源。理解计算机内存CPU和其它硬件怎么工作可以帮助你理解计算机是怎么工作的。汇编语言是非常底层的语言。其指令对应机器码指令。在C语言中简单的if-else可能需要复杂的汇编语句。理解汇编语言和计算机原理，有助于理解计算机和程序如何交互。教你写更有效率的代码，让你成为一个更好的程序员。 不管你做什么，保持续练习编程。最重要的是，注意安全，保持社交距离，注意安全。 翻译自 ：https://dev.to/realedwintorres/50-ways-you-can-improve-as-a-programmer-7g2","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📣📒🔖-读文章和读书的区别","slug":"📣📒🔖-读文章和读书的区别","date":"2021-12-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.229Z","comments":true,"path":"2021/undefined/24/📣📒🔖-读文章和读书的区别/","link":"","permalink":"http://example.com/2021/undefined/24/%F0%9F%93%A3%F0%9F%93%92%F0%9F%94%96-%E8%AF%BB%E6%96%87%E7%AB%A0%E5%92%8C%E8%AF%BB%E4%B9%A6%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.书里有成体系的知识，文章里没有。书一般都是点到线，线到面 ，面面连接，还可能到空间，到N维；文章可能只是个点，无法体系化，组织化，只有碎片化。 体系化vs 碎片化系统的知识跟碎片化的知识还有有不一样的，读一本书，可能你会忘了书具体内容，但知识的架构不容易忘记，读文章，只是往脑子里倒碎片，建立不起结构，一来不能有效提高思维和认知能力，二来不能增加知识储备。 深度和广度现在很多写的好的文章，的确很有深度，也能引人思考，但由于篇幅所限，它没办法呈现出一个完整的知识体系，却偏偏还给人带来一种“我都了解到了”的错觉，但其实这些，不过是某个知识体系里的冰山一角而已。 2.文章相对书籍实效性更强，书籍信息相对滞后比如某个框架发布了新版本，用不了几天，网上就会有很多雨后春笋般的解读文章，但是关于这个框架的书籍不会马上出现。 3. 信息刺激书一般是作者的一段时间的心得体会和实际经验而来，是二手资料，有些好的书籍可能经过作者好几年打磨。文章可能是三手，N手资料，网上高质量的原创文章很少，很多相同技术点的文章都是互抄，可能没经过自己的实际检验，拾人牙慧。有的人写文章仅仅是自己知识总结，你可能无法站在作者的角度理解他当时面临的问题。而书籍，更多是为了传播知识，发表观点。 4.对人的影响不同长时间的碎片化阅读，得到的也是碎片化的知识，长此以往，会造成你的注意力无法长期集中，一旦想认真地读一些东西，你会发现你的注意力很难保持超过十五分钟。这也意味着你的耐心被消磨掉了。碎片化知识好比竹孔中观天，所见有限；以瓢量海水，所得无几；长期沉浸其中，会使人变得轻佻浮躁。 一个长期通过碎片化来构建自己知识体系和世界观的人和一个长期通过书籍获取知识的人，踏实程度，看问题的角度和深度有很大不同。举个例子，很多人本科毕业后，也在不断学习，可是和读博士读研究生的人比较还是有很大不同，这些人接受的教育是系统化，体系化的，有了知识闭环。 再比如，计算机专业的程序员和非计算机专业的程序员，在一定的阶段所表现出的素质也有很大不同，很多野路子出身的程序员没有高工指导，今天学点这个，明天学点哪个，始终停留在门外，无法将知识融会贯通。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📣📝-功夫在诗外，优秀文章精选","slug":"📣📝-功夫在诗外，优秀文章精选","date":"2021-12-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.229Z","comments":true,"path":"2021/undefined/24/📣📝-功夫在诗外，优秀文章精选/","link":"","permalink":"http://example.com/2021/undefined/24/%F0%9F%93%A3%F0%9F%93%9D-%E5%8A%9F%E5%A4%AB%E5%9C%A8%E8%AF%97%E5%A4%96%EF%BC%8C%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0%E7%B2%BE%E9%80%89/","excerpt":"","text":"故不积跬步，无以至千里；不积小流，无以成江海。 ：学习要脚踏实地，注意积累。 骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。 ：学习要善于坚持，半途而废者，一事无成。——《劝学》 满招损，谦受益，功夫在字外。 —— 《笔中情》 而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也. ：想做成一件事，不容易，要具备目标，自身条件，外部环境。 —— 《游褒禅山记》 完美是优秀的天敌 —— 《算法图解》","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"👨🍳🐓-如何炖好一碗鸡汤","slug":"👨🍳🐓-如何炖好一碗鸡汤","date":"2021-12-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.244Z","comments":true,"path":"2021/undefined/24/👨🍳🐓-如何炖好一碗鸡汤/","link":"","permalink":"http://example.com/2021/undefined/24/%F0%9F%91%A8%F0%9F%8D%B3%F0%9F%90%93-%E5%A6%82%E4%BD%95%E7%82%96%E5%A5%BD%E4%B8%80%E7%A2%97%E9%B8%A1%E6%B1%A4/","excerpt":"","text":"鸡汤具有补气，鸡肉本身也是优秀蛋白质。 1.不要整只炖，一定要切块，洗干净 2.用水焯一下，去除浮沫 3.热锅滑油，让鸡肉表面紧实 4.一定要用砂锅 5.老母鸡最佳 6.小茴香和白豆蔻记得放 7.先大火后小火，放盐后再中火 8.表明有黄油，汤汁清澈最佳","categories":[],"tags":[{"name":"美食记录","slug":"美食记录","permalink":"http://example.com/tags/%E7%BE%8E%E9%A3%9F%E8%AE%B0%E5%BD%95/"}]},{"title":"⛵︎验证码（14）按下开机键后，电脑都干了些什么？","slug":"⛵︎验证码（14）按下开机键后，电脑都干了些什么？","date":"2021-12-22T16:00:00.000Z","updated":"2022-06-10T01:04:40.226Z","comments":true,"path":"2021/undefined/22/⛵︎验证码（14）按下开机键后，电脑都干了些什么？/","link":"","permalink":"http://example.com/2021/undefined/22/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%8814%EF%BC%89%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE%E5%90%8E%EF%BC%8C%E7%94%B5%E8%84%91%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"主流程1.通电2.北桥通电，南桥通电3.BIOS 硬件自检4.装载操作系统主要分三个硬件部分 1.BIOS ROM2. 内存 RAM3.硬盘 引导程序 操作系统① 开机访问0xFFFF0地址② 跳转到BIOS ROM的初始化程序③ 把BIOS ROM中的初始化程序复制到内存中执行④ 初始化程序 首先初始化硬件，然后在硬盘中找到 引导程序。⑤ 将引导程序复制到 内存的 0x07c00，并执行⑥ 引导程序 将硬盘的内容复制到内存中。⑦ 跳到内存中操作系统的开始地址，开始执行操作系统。⑧ 执行操作系统程序。 按下开机键后，电脑都干了些什么？","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码-(13)--CPU实现加法","slug":"⛵︎验证码-(13)--CPU实现加法","date":"2021-12-21T16:00:00.000Z","updated":"2022-06-10T01:04:40.226Z","comments":true,"path":"2021/undefined/21/⛵︎验证码-(13)--CPU实现加法/","link":"","permalink":"http://example.com/2021/undefined/21/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81-(13)--CPU%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95/","excerpt":"","text":"CPU加法是加法寄存器实现的，寄存器内部由二极管构成的各种门组成的。 二进制的进位或门的输出 与非门的输出 一个或门和一个与非门，简单组合之后 下表总结了或门和与非门的输出，并将其与我们想要的结果进行了对比。 注意，我们想要的是1，那么这种情况只有在或门和与非门的输出都为1时才会出现。这表明两个输出端可以通过一个与门连接到一起。 《编码：隐匿在计算机软硬件背后的语言 》十一、十二章","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码-(12)-CPU都干了什么事","slug":"⛵︎验证码-(12)-CPU都干了什么事","date":"2021-12-16T16:00:00.000Z","updated":"2022-06-10T01:04:40.225Z","comments":true,"path":"2021/undefined/16/⛵︎验证码-(12)-CPU都干了什么事/","link":"","permalink":"http://example.com/2021/undefined/16/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81-(12)-CPU%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B/","excerpt":"","text":"1.运算数学运算指令，加减乘除 2.从内存读取数据LOAD指令 3.存贮数据到内存STORE指令 cpu指令能做的事并不多，主要是以上几项，这是一种抽象，电脑应用五花八门，但是cpu指令就像乐高一样，各种功能组合就会出现不同的应用体验。当前的计算机发展主要是计算速度，其组成原理仍然是各种逻辑门，而衡量运算速度的一个重要指标是晶体管数量。 下图为1971年以来，晶体管数量增长趋势。 举个例子：苹果，自2007年发布以来，屏幕越来越大，速度越来约快，内存和硬盘容量一直在增加。但是手机能做的事没有变，拍照，看视频，听声音，浏览网页，发展了它仍然只是一台微型电脑计算机。 苹果系列处理器性能分析： 汇编指令苹果M1 Pro&#x2F;Max处理器性能“震撼”的秘密是什么？CPU指令、机器码、程序和汇编语言","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码-(11)-操作系统底层库和接口","slug":"⛵︎验证码-(11)-操作系统底层库和接口","date":"2021-12-02T16:00:00.000Z","updated":"2022-06-10T01:04:40.224Z","comments":true,"path":"2021/undefined/02/⛵︎验证码-(11)-操作系统底层库和接口/","link":"","permalink":"http://example.com/2021/undefined/02/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81-(11)-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E5%BA%93%E5%92%8C%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"最近在思考一个问题，电脑没有操作系统可以吗答案是可以。为什么要搞一个操作系统呢，答案之一，操作系统为计算机和开发者提供了各种库和接口。我们也可以自己写这些硬件接口驱动，底层库，抽象接口，这就是操作系统的雏形了。今天就探究一下linux的那些库(windows,mac没开源，也探究不了啊😳) Linux核心库Linux内的各种层，还显示了在用户空间和内核空间之间的分离。 ###内核内API在不同子系统间使用了数个内核内部API。其中一些是跨越多个发行版保持稳定的，另一些则不然。对于内核内API不作担保。维护者和贡献者可以在任何时候增加或变更它们[43]。 内核内API的例子包括针对下列类别设备驱动程序的软件框架&#x2F;API： Video4Linux – 用于视频捕捉硬件。 高级Linux声音体系（ALSA） – 用于声卡。 New API – 用于网络接口控制器。 直接渲染管理器 – 用于图形加速器。 KMS驱动器 – 用于视频显示控制器。 mac80211 – 用于无线网络接口控制器[44]。 The Linux API is composed out of the System Call Interface of the Linux kernel, the GNU C Library (by GNU), libcgroup,[1] libdrm, libalsa and libevdev[2] (by freedesktop.org). C标准库： GNU CGNU C库即glibc，是GNU项目对C标准库的实现。并不是所有的标准C函数都能在glibc中找到：大部分数学函数其实由libm实现，它是另外的一个库。 目前glibc是Linux上使用最广泛的C库。 glibc 的主体，分布 &#x2F;lib 与 &#x2F;usr&#x2F;lib 中，包括 libc 标准 C 函式库、libm 数学函式库、libcrypt 加密与编码函式库、libdb 资料库函式库、libpthread 行程多执行绪函式库、libnss 网路服务函式库 ….The GNU C Library is a wrapper around the Linux kernel System Call Interface.GNU C 库是 Linux 内核系统调用接口的包装器 Abstraction APIs 抽象接口在某些情况下，内核过于底层，开发者需要更高一层的抽象。当然，这些仍然需要在底层 Linux API 之上工作。OpenGL is indeed an abstraction API to make use of diverse GPUs of multiple vendors without the need to program for each one specifically.OpenGL 确实是一种抽象 API，可以利用多个供应商的不同 GPU，而无需专门为每个 GPU 进行编程。 [1] https://zh.wikipedia.org/wiki/Linux%E5%86%85%E6%A0%B8[2] https://en.wikipedia.org/wiki/Linux_kernel_interfaces#Linux_API[3] Linux中形形色色的接口API和ABI[4] 什么是 C&#x2F;C++ 标准库[5] 《linux&#x2F;unix 系统编程手册》chapter 3","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码---(10)--操作系统之进程通信","slug":"⛵︎验证码---(10)--操作系统之进程通信","date":"2021-12-01T16:00:00.000Z","updated":"2022-06-10T01:04:40.183Z","comments":true,"path":"2021/undefined/01/⛵︎验证码---(10)--操作系统之进程通信/","link":"","permalink":"http://example.com/2021/undefined/01/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81---(10)--%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"","text":"linux进程状态简单版 运行状态（Running） 就绪状态（Ready） 等待状态，又称阻塞状态（Blocked） 创建状态（New） 结束状态（Exit) 详细版 进程的创建Linux最早产生的进程是启动过程中创建的idle进程，pid号为0，该进程会创建一个内核线程，该线程进行一系列初始化动作后最终会执行&#x2F;sbin&#x2F;init文件，执行该文件的结果是运行模式从核心态切换到了用户态，该线程演变成了用户进程init，pid号为1。init进程是一个非常重要的进程，一切用户态进程都是它的后代进程。 在UNIX中，操作系统初始化时所创建的1号进程是所有用户进程的祖先，1号进程为每个从终端登录入系统的用户创建一个终端进程，这些终端进程又会利用“进程创建”系统调用创建子进程，从而形成进程间的层次体系，称为进程树或进程族系。 Linux系统执行新任务的典型方法是通过fork()&#x2F;exec()函数。通常fork()创建一个新进程，然后新进程通过调用exec系列函数执行真正的任务 进程由以下4方面组成① 进程包括至少一个可执行程序，含有代码和初始数据，一般在进程创建时说明。注意，可执行程序可以被多个进程共享，换句话说，多个进程可能运行同一个可执行程序。② 进程包括一个独立的进程用户空间，在进程创建时由操作系统分配。③ 进程包括系统资源。这是指在进程创建及执行过程中，由操作系统分配给进程的系统资源，包括I&#x2F;O设备、文件等。④ 进程包括一个执行栈区，包含运行现场信息，如子程序调用时所压栈帧，系统调用时所压的栈帧等，这是进程运行及进程调度进行处理机切换时所要涉及的数据结构。 pid有什么用 在操作系统中，每个进程都有一个唯一的内部数字标识符，它可以是图3.2中进程控制块的地址值，或者是可以映射出进程控制块位置的某种索引值。标识符是非常有用的，操作系统控制的其他表格中可以用进程标识符来定位进程控制块。例如，文件访问的有关表格中可以存入进程标识符，说明该文件已被哪几个进程打开；当进程相互通信时，通过进程标识符说明要交换信息的对方进程；当进程创建子进程时，用进程标识符来指明父进程或子进程。这里的进程标识符是一个数字式的系统内码，通过它可以建立其他表格与进程控制块之间的联系。 操作系统进程通信实例1.手机微信分享，比如网易云音乐分享到微信朋友圈网易云音乐 &#x3D;&gt; 微信朋友圈 2.apple store 通过浏览器打开 谷歌浏览器 &#x3D;&gt; apple Store 3.uni-app 打开小程序 HBuilderX &#x3D;&gt; 微信开发者工具 4. selenium 调用Google浏览器使用selenium，driver做网页测试 5.AndPods调用蓝牙 6.h5调用微信支付js &#x3D;&gt; 微信app 进程之间究竟有哪些通信方式浏览器为什么能唤起App的页面微信网页开发 &#x2F;JS-SDK说明文档","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码---(9)--CPU多任务原理","slug":"⛵︎验证码---(9)--CPU多任务原理","date":"2021-11-29T16:00:00.000Z","updated":"2022-06-10T01:04:40.183Z","comments":true,"path":"2021/undefined/29/⛵︎验证码---(9)--CPU多任务原理/","link":"","permalink":"http://example.com/2021/undefined/29/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81---(9)--CPU%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8E%9F%E7%90%86/","excerpt":"","text":"CPU三项基本工作就是这样去执行读出数据、处理数据和往内存写数据 并发和并行 进程和线程进程 进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，一个进程就是一个程序的运行实例。 线程 线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 联系线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 区别：理解它们的差别，从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等） 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位 单核cpu实现多任务原理对于单cpu，多个进程在这个单cpu中是并发运行，根据时间片读取上下文+执行程序+保存上下文 进程，线程与多核，多cpu之间的关系 并发与并行的区别是什么Chrome架构：仅仅打开了1个页面，为什么有4个进程？CPU工作原理揭秘 备注：1毫秒(ms) &#x3D; 1000(微秒)us","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"-🎨🎨-git-push-为什么必须要先-git-pull","slug":"-🎨🎨-git-push-为什么必须要先-git-pull","date":"2021-11-17T16:00:00.000Z","updated":"2022-06-10T01:04:40.181Z","comments":true,"path":"2021/undefined/17/-🎨🎨-git-push-为什么必须要先-git-pull/","link":"","permalink":"http://example.com/2021/undefined/17/-%F0%9F%8E%A8%F0%9F%8E%A8-git-push-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E8%A6%81%E5%85%88-git-pull/","excerpt":"","text":"(e.g., ‘git pull …’) before pushing againUse git pull to pull the latest changes from the remote repository to your local repository. In this case, pulling changes will require a merge because you have made changes to your local repository. I’ll provide an example and a picture to explain. Let’s assume your last pull from origin&#x2F;branch was at Commit B. You have completed and committed some work (Commit C). At the same time, someone else has completed their work and pushed it to origin&#x2F;branch (Commit D). There will need to be a merge between these two branches. 12345local branch: --- Commit C / / /origin/branch: Commit A ------ Commit B ---- Commit D Because you are the one that wants to push, Git forces you to perform the merge. To do so, you must first pull the changes from origin&#x2F;branch. 12345local branch: --- Commit C -- Commit E / / / / / / origin/branch: Commit A ------ Commit B ---- Commit D After completing the merge, you will now be allowed to fast-forward origin&#x2F;branch to Commit E by pushing your changes. Git requires that you handle merges yourself, because a merge may lead to conflicts.","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码--（8）液晶显示器原理","slug":"⛵︎验证码--（8）液晶显示器原理","date":"2021-11-17T16:00:00.000Z","updated":"2022-06-10T01:04:40.182Z","comments":true,"path":"2021/undefined/17/⛵︎验证码--（8）液晶显示器原理/","link":"","permalink":"http://example.com/2021/undefined/17/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81--%EF%BC%888%EF%BC%89%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA%E5%99%A8%E5%8E%9F%E7%90%86/","excerpt":"","text":"显示器接口 VGAVGA接头：针数为15的视频接口，主要用于老式的电脑输出。VGA输出和传递的是模拟信号。大家都知道计算机显卡产生的是数字信号，显示器使用的也是数字信号。所以使用VGA的视频接口相当于是经历了一个数模转换和一次模数转换。信号损失，显示较为模糊。 HDMIHDMI是一种高清视频接口，在目前主流笔记本、液晶电视、显卡、主板中都比较常见。HDMI是一种数字化视频&#x2F;音频接口技术，是适合影像传输的专用型数字化接口，其可同时传送音频和影音信号，最高数据传输速度为5Gbps，可支持1080P，720P的全高清格式视频输出，是目前最为流行的高清接口，这是普通的VGA显示接口所无法比拟的，犹如宽带中电话线宽带与光纤一样，传输数据能力区别很大。 DVIDVI接口：DVI接口有两个标准，25针和29针，如下图所示。直观来说，这两种接口没有区别。DVI接口传输的是数字信号，可以传输大分辨率的视频信号。DVI连接计算机显卡和显示器时不用发生转换，所以信号没有损失。 准确说，DVI分为DVI-I和DVI-D 前者依然是模拟信号输出 后者则是完全的高清数字输出 使用DVI-I的显卡接口可以使用转接头转成VGA输出 后者则不能 DVI-I的实际画面输出和VGA没有本质的区别 DVI-D和HDMI才是真正的数字无损输出 DPDP接口DP（Display Port）接口是HDMI接口的竞争对手。在一些显卡与显示器上，除了有HDMI接口，也带有DP接口。目前DP接口发展到1.4版本，能传输10bit的4K 120Hz视频，也可以支持8K 60Hz视频。DP1.4兼容USB Type-C接口，这就意味着，我们可以使用DP1.4协议，在USB 3.1传输数据的同时，同步传输高清视频。从趋势来看，这对于推动周边影音及影像设备的升级，是非常有好处的。而且，DP接口也可以单根线同步传输声音，达到使用显示器声音的使用方式。 USB Type-CUSB Type-C接口USB接口早已被大家所熟知，以往USB接口被设计用来传输数据，所以它在移动硬盘等存储设备的使用上非常常见。现在USB 3.1 Gen2的速度已经达到10Gbps，设计标准也可以满足视频、数据兼顾传输，所以在一些显示器上，也能够发现USB 3.1接口。现在的USB3.1接口，已经能够满足4K 30P的分辨率显示，大致与HDMI1.4在同一水平。但它以后再进行升级，必将能成为最通用的显示传输方式。需要注意的是，USB 3.1 Gen1就是USB 3.0，而USB 3.1 Gen2才是真正的USB3.1。 雷电接口雷电接口雷电（thunderbolt）接口在苹果电脑上用的非常多，苹果的中文官网将其译为雷雳。它以速度快，传输稳定而著称。雷电接口的技术融合了PCI Express和DisplayPort（就是上面说的DP口）两种通信协议。其中PCI Express用于数据传输，可以非常方便地进行任何类型设备扩展；DisplayPort用于显示，能同步传输1080p乃至4K视频和最多八声道音频。并且两条通道在传输时都有自己单独的通道，不会产生任何干扰。 驱动版接受数字信号和模拟信号，经过解码器，解码加载到 scaler芯片中####（1）A／D转换电路 A／D转换电路即模／数转换器，用以将VGA接口输出的模拟R、G、B信号转换为数字信号，然后送到Sealer电路进行处理。 早期的液晶显示器，一般单独设立一块A／D转换芯片（如AD9883、AD9884等），现在生产的液晶显示器，大多已将A／D转换电路集成在Scaler芯片中。####（2） Sealer电路Sealer电路的名称较多，如图像缩放电路、主控电路、图像控制器等。Sealer电路的核心是一块大规模集成电路，称为Sealer芯片，其作用是对A&#x2F;D转换得到的数字信号或TMDS接收器输出的数据和时钟信号，进行缩放、画质增强等处理，再经输出接口电路送至液晶面板，最后，由液面板时控制1C（TCON）将信号传输至面板上的行列驱动IC. Sealer芯片的性能基本上决定了信号处理的极限能力。另外，在Sealer电路中，一般还集成有屏显电路（OSD电路）。 液晶显示器为什么要对信号进行缩放处理呢？这是由于一个面板的画素位置与分辨率在制造完成后就已经固定，但是影音装置输出的分辨率却是多元的，当液晶面板必须接收不同分辨率的影音信号时，就要经过缩放处理才能适合一个屏幕的大小，所以信号需要经过Sealer芯片进行缩放处理。 读懂电视进化史：CRT、背投、PDP、LCD、OLED显示器基本构成薄薄的液晶显示器是如何显示各种图案显示器接口类型","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码-（7）-显卡构成-与-render-pipeline","slug":"⛵︎验证码-（7）-显卡构成-与-render-pipeline","date":"2021-11-16T16:00:00.000Z","updated":"2022-06-10T01:04:40.181Z","comments":true,"path":"2021/undefined/16/⛵︎验证码-（7）-显卡构成-与-render-pipeline/","link":"","permalink":"http://example.com/2021/undefined/16/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81-%EF%BC%887%EF%BC%89-%E6%98%BE%E5%8D%A1%E6%9E%84%E6%88%90-%E4%B8%8E-render-pipeline/","excerpt":"","text":"显卡构成1.GPU(核心部件) CPU vs GPUgpu 线程多，计算能力强cpu 线程少，但逻辑处理能力强 一般说来，衡量GPU工作能力的参数有三项：流处理器数量和核心、显存工作频率。 核心频率显卡的核心频率是指显示核心的工作频率，其工作频率在一定程度上可以反映出显示核心的性能，但显卡的性能是由核心频率、流处理器单元、显存频率、显存位宽等等多方面的情况所决定的。 2.显存显存的参数有：显存类型，容量，位宽，频率。按常理说三者是越高越好。 显存与分辨率1680 * 1050分辨率，1G显存1440 * 900及其一下，512M就可以1920 * 1080，至少1.5G显存。 显存类型由于现在显存都基于DDR系列内存改造，DDR因为能在时钟的上升沿和下降沿都能传送数据，所以比SDR同频效率高了一倍，因而就有了等效频率这一说法。GDDR3和DDR3都是等效两倍，而GDDR5是2倍于GDDR3的数据预取量和DQ并行总线，使得GDDR5显存的实际速度又快了一倍，等效4倍。 显存容量（显存提供临时存储功能，大显存有用，但不是那么重要，架构不行显存再大也是耍流氓。比如显存是停车场，如果停车场马路不够宽（位宽bit），汽车速度不够快（显存频率MHz），那么这个停车场的吞吐量就很小，修个超大停车场纯属浪费资源。） 3.PCB板4.风扇5.显示输出接口显卡作为显示信息处理部件，处理了图像信息要有输出的地方，不然处理完也然并卵。目前显卡常见采用三种输出接口：VGA、HDMI(包含mini HDMI)、DVI、DP（包含miniDP）。VGA就是显卡上输出模拟信号的接口，VGA接口，也称作D-Sub接口。VGA接口是显卡上应用非常广泛的接口类型，常见于中低端显卡。而高端和旗舰显卡都取消了这款接口，使用VGA接口的要使用转接头进行转换。 显卡用途分类GeForce:显示器用的，比如电脑的显卡，消费级显卡，打游戏用的采用 NVIDIA Ampere架构 Quadro: 图形卡，超贵的专业卡，专业驱动+大显存版GeForce采用Turing(图灵)架构和RTX平台是用来做一些C4D、3D MAX等专业领域的显卡 Titan: 图形卡，消费级卡皇，GeForce和Quadro的合体配置了特殊的图形处理集群 Tesla: 计算卡，人工智能和深度学习用采用 NVIDIA Ampere架构 这类的显卡不只是性能强劲，更可以通过接口连接，并联串联来达到增强性能，达到更高性能的计算目的，所以在这种场所中这种类型的显卡也被称为计算卡。 消费级显卡 参数对比高端显卡七彩虹（Colorful）九段iGame GeForce RTX 3090 Kudan 24G 影驰（Galaxy）GeForce RTX 3080 Ti 星曜 OC N卡&#x2F;赛博朋克 电脑电竞游戏专业显卡参数 中端显卡七彩虹（Colorful）RTX3060Ti系列RTX3060Ti电竞游戏电脑显卡 七彩虹 Colorful RTX 2060&#x2F;2060 低端显卡七彩虹（Colorful） GTX&#x2F;1650&#x2F;710&#x2F;1030&#x2F;1050ti 游戏办公独立显卡 入门级显卡七彩虹（Colorful）GT1030黄金版2G&#x2F;710 七彩虹（Colorful） GT710 黄金版 NVIDIA 架构进化史 教你深入浅出做个硬件知识小达人电脑基础知识—显卡从GTX到RTX，NVIDIA GPU架构的变迁史桌面显卡天梯图科普向——全面认识显卡构成和各类参数https://mp.processon.com/view/link/5ec33e0ff346fb690701ff6cGPU渲染管线之旅","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码-（5）chrome浏览器渲染图片跨平台","slug":"⛵︎验证码-（5）chrome浏览器渲染图片跨平台","date":"2021-11-14T16:00:00.000Z","updated":"2022-06-10T01:04:40.180Z","comments":true,"path":"2021/undefined/14/⛵︎验证码-（5）chrome浏览器渲染图片跨平台/","link":"","permalink":"http://example.com/2021/undefined/14/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81-%EF%BC%885%EF%BC%89chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%9B%BE%E7%89%87%E8%B7%A8%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"问题：chrome怎么跨平台chrome 在安卓，iOS，Mac,windows,linux都有安装包，chrome作为浏览器怎么做到兼容问题的呢。 chrome渲染图像过程html =&gt; dom =&gt; skia webGl =&gt; openGL 解决方案：skia Skia Graphics Library（SGL）是一个由C++编写的开放源代码图形库Skia主要的类别是SkCanvas，所有的绘图功能都是实现于此类别。以下是SGL简单的代码： 1234SkCanvas* can = GraphicsJNI::getNativeCanvas(...); SkPaint paint; paint.setARGB(255, 0, 0, 255);can-&gt;drawText(&quot;Hello, world&quot;, 12, 10, 10, paint); 一颗像素的诞生Life of a pixeskia简介","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎验证码-（4）计算机-图像渲染，图片解码","slug":"⛵︎验证码-（4）计算机-图像渲染，图片解码","date":"2021-11-08T16:00:00.000Z","updated":"2022-06-10T01:04:40.180Z","comments":true,"path":"2021/undefined/08/⛵︎验证码-（4）计算机-图像渲染，图片解码/","link":"","permalink":"http://example.com/2021/undefined/08/%E2%9B%B5%EF%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81-%EF%BC%884%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%EF%BC%8C%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81/","excerpt":"","text":"从理论上，我可以用上图的这种键盘按照一定的编码敲出一长串0、1数字序列，再加一个jpg&#x2F;png的后缀名保存。 打开文件时，是将这些数据送入内存，图片查看程序控制CPU，根据后缀名对数据进行解码、解压后得到图像本身的数据——每个像素的RGB等。 再历经前面所述的一大串过程，CPU的数据再经过显卡和显示器，最终我就能看到一张滑稽的照片 计算机怎么绘制系统UI的 桌面开发UI原理windows图像绘制操作系统有一套 GUI API ,提供给开发者调用电脑不同应用，使用不同绘制模型，比如windows10 系统，同时运行 画布，有道云笔记，魔兽世界3D游戏 安卓图像绘制 下一篇以chrome为例，梳理操作系统和应用之间的调用关系。 一步一步解码 PNG 图片《编码，隐藏在计算机软硬件背后的语言》猴子也能看懂的渲染管线（Render Pipeline)GPU 观察","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎小小验证码（3）文本和二进制互转","slug":"⛵︎小小验证码（3）文本和二进制互转","date":"2021-11-07T16:00:00.000Z","updated":"2022-06-10T01:04:40.179Z","comments":true,"path":"2021/undefined/07/⛵︎小小验证码（3）文本和二进制互转/","link":"","permalink":"http://example.com/2021/undefined/07/%E2%9B%B5%EF%B8%8E%E5%B0%8F%E5%B0%8F%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%883%EF%BC%89%E6%96%87%E6%9C%AC%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BA%92%E8%BD%AC/","excerpt":"","text":"JS字符串与二进制的相互转化的方法，具体代码如下所示： &#x2F;&#x2F; 字符串转ascii码，用charCodeAt();&#x2F;&#x2F; ascii码转字符串，用fromCharCode(); 123var str = &quot;A&quot;;var code = str.charCodeAt();var str2 = String.fromCharCode(code); 文本转二机制，基本示例123var a = &quot;i&quot;;console.log(a.charCodeAt()); //105console.log(a.charCodeAt().toString(2)); //1101001 123var a = &quot;我&quot;;console.log(a.charCodeAt()); //25105console.log(a.charCodeAt().toString(2)); //110001000010001 12345var a = &quot;我们&quot;;console.log(a.length); //2var list = a.split(&quot;&quot;);console.log(list.length); //2&lt;br&gt;console.log(a.charCodeAt().toString(2)); //110001000010001 100111011101100 二进制转文本1234let byte = &quot;110001000010001&quot;const asciiCode = parseInt(byte,2);const charValue = String.fromCharCode(asciiCode)// 我 多个字符互转1234567891011121314151617181920212223242526272829303132// 将字符串转换成二进制形式，中间用空格隔开function strToBinary(str)&#123; var result = []; var list = str.split(&quot;&quot;); for(var i=0;i&lt;list.length;i++)&#123; if(i != 0)&#123; result.push(&quot; &quot;); &#125; var item = list[i]; var binaryStr = item.charCodeAt().toString(2); result.push(binartStr); &#125; return result.join(&quot;&quot;);&#125;console.log(strToBinary(&quot;我们&quot;)); // 110001000010001 100111011101100console.log(strToBinary(&quot;@%$+&quot;)); // 1000000 100101 100100 101011// 将二进制字符串转换成Unicode字符串function binaryToStr(str)&#123; var result = []; var list = str.split(&quot; &quot;); for(var i=0;i&lt;list.length;i++)&#123; var item = list[i]; var asciiCode = parseInt(item,2); var charValue = String.fromCharCode(asciiCode); result.push(charValue); &#125; return result.join(&quot;&quot;);&#125; console.log(binaryToStr(&quot;110001000010001 100111011101100&quot;)); // 我们console.log(binaryToStr(&quot;1000000 100101 100100 101011&quot;)); // @%$+","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎小小验证码（2）responseType、Mime","slug":"⛵︎小小验证码（2）responseType、Mime","date":"2021-11-06T16:00:00.000Z","updated":"2022-06-10T01:04:40.179Z","comments":true,"path":"2021/undefined/06/⛵︎小小验证码（2）responseType、Mime/","link":"","permalink":"http://example.com/2021/undefined/06/%E2%9B%B5%EF%B8%8E%E5%B0%8F%E5%B0%8F%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%882%EF%BC%89responseType%E3%80%81Mime/","excerpt":"","text":"有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。 xhr.overrideMimeType()overrideMimeType是xhr level 1就有的方法如果服务器没有指定一个[Content-Type] 头, XMLHttpRequest 默认MIME类型为&quot;text/xml&quot;. 如果接受的数据不是有效的XML，将会出现格”格式不正确“的错误。你能够通过调用 overrideMimeType() 指定各种类型来避免这种情况。 12345678// Interpret the received data as plain textreq = new XMLHttpRequest();req.overrideMimeType(&quot;text/plain&quot;);req.addEventListener(&quot;load&quot;, callback, false);req.open(&quot;get&quot;, url);req.send(); 再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。 下面是一个获取图片文件的代码示例： 123456789101112131415161718var xhr = new XMLHttpRequest();//向 server 端获取一张图片xhr.open(&#x27;GET&#x27;, &#x27;/path/to/image.png&#x27;, true);// 这行是关键！//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集xhr.overrideMimeType(&#x27;text/plain; charset=x-user-defined&#x27;);xhr.onreadystatechange = function(e) &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //通过 responseText 来获取图片文件对应的二进制字符串 var binStr = this.responseText; //然后自己再想方法将逐个字节还原为二进制数据 // 文本转二机制 &#125;&#125;;xhr.send(); xhr.responseType下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。 1234567891011121314var xhr = new XMLHttpRequest();xhr.open(&#x27;GET&#x27;, &#x27;/path/to/image.png&#x27;, true);//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`//xhr.responseType = &#x27;arrayBuffer&#x27;;xhr.responseType = &#x27;blob&#x27;;xhr.onload = function(e) &#123; if (this.status == 200) &#123; var blob = this.response; ... &#125;&#125;;xhr.send(); 简单来说，responseType就是把文本转换成 二进制了，二进制和文本怎么转换呢,请看下文分解","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"⛵︎小小验证码（1）--数据流转图片","slug":"⛵︎小小验证码（1）--数据流转图片","date":"2021-11-05T16:00:00.000Z","updated":"2022-06-10T01:04:40.178Z","comments":true,"path":"2021/undefined/05/⛵︎小小验证码（1）--数据流转图片/","link":"","permalink":"http://example.com/2021/undefined/05/%E2%9B%B5%EF%B8%8E%E5%B0%8F%E5%B0%8F%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%881%EF%BC%89--%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC%E5%9B%BE%E7%89%87/","excerpt":"","text":"1.responseType: blob1.1 URL.createObjectURL(blob);1const url = window.URL.createObjectURL(blob); Object URL 是一种伪协议，也被称为 Blob URL。它允许 Blob 或 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 URL.createObjectURL 方法来创建 Blob URL，该方法接收一个 Blob 对象，并为其创建一个唯一的 URL，其形式为 blob:&#x2F;，对应的示例如下： 1blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641 浏览器内部为每个通过 URL.createObjectURL 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 Blob。生成的 URL 仅在当前文档打开的状态下才有效。但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。 上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。 针对这个问题，我们可以调用 URL.revokeObjectURL(url) 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。 1.2 fileReader.readAsDataURL 转base64 12345678910111213141516 const blobToBase64 = (blob) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const fileReader = new FileReader(); fileReader.onload = e =&gt; &#123; resolve(e.target.result); &#125;; fileReader.readAsDataURL(blob); fileReader.onerror = () =&gt; &#123; reject(new Error(&quot;文件流异常&quot;)); &#125;; &#125;); &#125;verificationCode().then(async blob =&gt; &#123; this.url = blobToBase64(blob)&#125; base64是 Data URI协议的一种实现，在1998年被确定，具体Data URI详细介绍。 1.3 blob 转 arraybuffer 转 base64123456789101112131415verificationCode().then(async blob =&gt; &#123; transformArrayBufferToBase64(response);&#125;const async transformArrayBufferToBase64 = (response) =&gt; &#123; response = await this.fileReadAsArrayBuffer(response); this.url = &quot;data:image/png;base64,&quot; + btoa( new Uint8Array(response).reduce( (data, byte) =&gt; data + String.fromCharCode(byte), &quot;&quot; ) ); &#125; 2.responseType: arraybuffer2.1 arraybuffer 转 base6412345678910verificationCode().then(blob =&gt; &#123; this.url = &quot;data:image/png;base64,&quot; + btoa( new Uint8Array(response).reduce( (data, byte) =&gt; data + String.fromCharCode(byte), &quot;&quot; ) );&#125; 3.额外知识点arraybuffer转Blob 12var buffer = new ArrayBuffer(16);var blob = new Blob([buffer]); blob转arraybuffer借助FileReader对象 1234567var blob = new Blob([1,2,3,4,5]);var reader = new FileReader();reader.onload = function() &#123; console.log(this.result);&#125;reader.readAsArrayBuffer(blob); 参考资源 玩转前端二进制前端二进制学习你真的会使用XMLHttpRequest吗JS字符串与二进制的相互转化实例代码详解玩转图片流Base64编码原理与应用Data URI详细介绍细说 Data URI 下一篇 读取后端验证码（二) resonpseType浅析","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎅📣-你的github是空的吗","slug":"🎅📣-你的github是空的吗","date":"2021-11-02T16:00:00.000Z","updated":"2022-06-10T01:04:40.176Z","comments":true,"path":"2021/undefined/02/🎅📣-你的github是空的吗/","link":"","permalink":"http://example.com/2021/undefined/02/%F0%9F%8E%85%F0%9F%93%A3-%E4%BD%A0%E7%9A%84github%E6%98%AF%E7%A9%BA%E7%9A%84%E5%90%97/","excerpt":"","text":"作为一个开发者，不经常对github提contributions并不意味着你写代码不咋滴，但是你失去了一个证明你是精神小伙的机会。为了改变这一点，以下有四个方面入手怎么给github做更多贡献1. Private repos搞一个私有库，每周至少在ReadMe.md中写句工作学习的总结，这样可以搞一个小册子 我没这样做，但是听别人这样弄了，这对100天代码练习和学习算法非常有用 2. 经常 commit在你写代码的时候可以做些小提交，一个工作日3个小时最佳 找到一些最终起作用的东西，提交 一天结束了，提交一下今天干了啥 写东西切代码可能会影响工作？先提交工作代码 3. Issues给一些项目提Issues看看有哪些没开发的东西❓ 点击下 new Issues,完善细节 保持任务的短小，想想他可以在一两个冲刺中实现吗 web开发每天处理issues。例如，用bootstrap 搞一个响应式导航栏 4. 格局记住 github的图表并不能证明你的价值，但如果它完全是空的，会给人留下不好的印象️ 当你的数据很火时，那么别人会把你看作是洞悉github和git概念的大佬. 这至少说明你是个有能力专业人士，而不是需要别人带的菜鸟，最起码不是个懒人。 主动把你学过的东西展示出来，尤其是自学的东西 结论这份清单并没有说完，还有很多方法比如fork一个项目的分支，推送一个PR，review代码，等等。 活跃在github上是一个展示专业知识的好方法，而且能学到你所做和不知道的东西 面试官会也看这个东西，为什么不给人留个好印象呢，而且这也不费什么劲。 我墙裂见你通过我上面的小步骤，好好搞一搞你的github, 然后再忙你的去。 翻译自 https://dev.to/techieeliot/is-your-github-empty-2gkh","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📣-前端常用命名","slug":"📣-前端常用命名","date":"2021-11-02T16:00:00.000Z","updated":"2022-06-10T01:04:40.178Z","comments":true,"path":"2021/undefined/02/📣-前端常用命名/","link":"","permalink":"http://example.com/2021/undefined/02/%F0%9F%93%A3-%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D/","excerpt":"","text":"背景在编码的过程中变量命名是一个容易忽略，又容易犯头疼的问题。例如在复杂的页面布局中 Class 的命名，同样一个结构在不同的上下文要表达的意思不一样，是采用通用命名呢？还是采用更具有描述性的业务相关词汇？但是呢还需要考虑到样式的复用、是否会冲突、被覆盖、组合命名的长度是否太长等问题。 在实际工作中，每个人都有自己命名风格和惯用词汇，有的喜欢使用英文简写、有的喜欢使用中英文结合、有的喜欢给变量加数据类型前缀、有的喜欢乱造词汇、有的甚至单词都拼写不正确。在看别人代码的过程中你是否像我一样无语，但也只能截图指出并吐槽二下，有些时候对方并不买单，改正。 每次到换工作的时候就更新博客，7 月下旬的高温天气就适合在家里码字，这次选择这个话题的原因是目前在网上还没有相关的文章来系统全面的论述有前端关代码变量命名的资料。Java 有《码出高效 - 阿里巴巴 Java 开发手册 终级版》，而前端这方面目前还是一个空白，虽然有很多代码规范，但是很少有人愿意在这方面去花心思，更多的是研究框架的源码、数据结构与算法和尝试新的技术，本人由于大脑开发有限、没有能力去啃这些骨头，只好捡一些很少有人去碰触的简单不费脑的知识点来考究一二，希望也能为前端的生态做出一点小贡献。 命名规则目前流行的经典命名规则有：**驼峰命名法、匈牙利命名法、下划线命名法、****帕斯卡命名法** 相关命名的具体规则请另行查阅。前端主要涉及到驼峰命名法，React 组件会用到帕斯卡命名法。 然后是变量命名规则： 变量名首字母必须为字母(a-z A-Z)，下划线(_)，或者美元符号($)开始 变量名只能是字母(a-z A-Z)，数字(0-9)，下划线(_)的组合，并且之间不能包含空格，数字不能放在变量名首位。 变量名不能使用编程语言的保留字。比如在 javascript 中不能使用 true, false, while, case, break 保留字等等。 命名风格这里给出一些在开发过程中约定成俗的通用规则，涉及 JavaScript, Typescript, 框架组件, 样式及目录。在文章中将使用【强制】来表示必须严格遵守，【推荐】来表示建议，【参考】来给出多种命名方式的一种。 1. 【强制】在 JavaScript 中使用驼峰命名法来表示变量，不能以下划线或美元符号作为开始和结束。 123456// 反例_name__namename_$namename$ 补充：由于受框架和第三方库及语言限制，不可能完全避免。例如：在 RxJs 中通常命名流的时候是以 变量名 + $ 的形式，在 Class 中定义私有变量时通常以 _ + 变量名 的方式来表示，在 Vue 中内部实例方法全部以 $ 开始，在 AngularJs 中内部方法以 $$ 开始，而 lodash 直接使用 _ 作为其别名。 2. 【强制】在代码中严禁使用拼音与中英文混合的方式，更不允许直接使用中文的方式。除了一些国际通用的中文名称，要视为英文外，其它禁止使用。 12345// 正例taobaotmallshanghaicoupons 12// 反例yhq [优惠券] 3. 【强制】类名使用大写驼峰命名法来表示，Typescript 中枚举值使用大写驼峰命名法表示。 123// 正例class User &#123;&#125;enum Color &#123;Red = 1, Green, Blue&#125; 12class user &#123;&#125; 4. 【强制】常量名全部大写，单词间使用下划线隔开，力求表达完整清楚，不要嫌名字长。&#x2F;&#x2F; 正例 1GOOGLE_MAP_TOKEN &#x2F;&#x2F; 反例 1TOKEN 5. 【建议】Typescript 中抽象类使用 Abstract 或 Base 开头；异常类使用 Exception 结尾。 1abstract class BaseDepartment &#123;&#125; 6. 【建议】在 TypeScript 中，类型使用 Type 作后缀，接口使用 I 作为前缀。 12type PropsType = &#123;&#125;interface ILoginProps &#123;&#125; 7. 【建议】 采用有意义的命名，在项目中坚持使用一种变量命名方式。不要 usr 与 user 混用 &#x2F;&#x2F; 正例 12usersgetUserByUid() &#x2F;&#x2F; 反例 12registerUsr()copyUserInfo() 8. 【建议】方法名必须准确表达该方法的行为，在多数情况下以动词开头 &#x2F;&#x2F; 正例 1234fetchCoupons()updateToken()createAccount()generateUniqueId() &#x2F;&#x2F; 反例 1getData() 9.【建议】可以使用单词简写，但是只局限于常用词汇，注意不同词汇的简写有可能冲突 &#x2F;&#x2F; 正例 1234setProps() [props -&gt; property]selectCouponsDlg() [dlg -&gt; dialog]readPkg() [pkg -&gt; package]previewTpl [tpl -&gt; template] &#x2F;&#x2F; 反例 1234vehicleDesc [desc -&gt; description]vehicleDesc [desc -&gt; descending]vehicleAesc [aesc -&gt; aescending]fetchUsr() [usr -&gt; user] 10. 【建议】在 Vue 和 Angular 中，模板语法中所有组件名使用中线命名法，在 React 中使用大写驼峰命名法来表示 12345678910// Vue&lt;el-button type=&quot;text&quot; @click=&quot;toDetail&quot;&gt;详情&lt;/el-button&gt;&lt;custom-component a-prop=&quot;prop&quot; /&gt;// Angular&lt;nz-sider [nzWidth]=&quot;200&quot; style=&quot;background:#fff&quot;&gt;&lt;/nz-sider&gt;// React&lt;SelectPicture data=&#123;this.images&#125; /&gt; 11. 【推荐】统一使用中线命名法来命名目录。 1|-- page-header | |-- PageHeader.vue 12. 【参考】在 Vue 模板语法中组件属性使用连字符命名法，在 Vue 中使用 JSX 则属性使用驼峰命名法，并且文件文以”.jsx”为文件类型。 12345&lt;Thumbnail withHeadPicture=&#123;true&#125; data=&#123;this.selectedImages[0]&#125; withDetail=&#123;this.enabledDetail&#125;/&gt; 13. 【强制】在服务名上使用 Service 后缀 1class UserService &#123;&#125; 14. 【建议】在 Vue 中组件文件名采用大写驼峰命名方式，React 同样如此，在 Angular 中以使用点和横杠来分隔文件名，并且符号名后面追加约定的类型后缀。 123456789101112// VueUser.vue// Angularapp.component.tshero-list.component.tsvalidation.directive.tsapp.module.tsuser-profile.service.ts// ReactUser.jsx 15. 【参考】在 React 中使用目录名称作为组件名，在目录内容直接使用index作为入口，在 Vue 中不可以，在 Angular 中可以将index作为模块的入口，当然也可以直接作为组件的入口，但这样和其整个命名风格有所背离。 123456// Vue|-- user-info | |-- UserInfo.vue// Angular |-- user-info | |-- user-info.component.ts | |-- index.ts// React |-- user-info | |-- index.jsx 16. 【建议】在工程中文档使用全大写命名 123README.mdCONTRIBUTORS.mdCHANGELOG.md 17. 【建议】在 Vue 中指令命名使用 filter 作为结束。所有引用命名使用 ref 作为后缀 123formatCouponsFilterinputRefselectRef 18. 【强制】测试文件以 .spec 或者 .test 作为命名的一部分。 12selectPicture.spec.jspageHeader.test.js 19. 【建议】复数化变量名称，而不是命名中包含集合类型名称。 1234567// 正例hostsusersvalidUsershostTexthostJsonportNumber 12345// 反例hostListuserListhostStrintPort 20. 【建议】在 for 循环中使用 i, j, k 来作为索引，使用 n 表示数量&#x2F;次数&#x2F;限制，使用 e 表示异常, 使用 evt 表示事件对象, 使用 cb 表示回调函数。 1234567for (let i = 0; i &lt; 10; i++) &#123; for (let j = 0; j &lt; 10; j++) &#123; for (let k = 0; k &lt; 10; k++) &#123; // do something &#125; &#125;&#125; 21. 【强制】在解构时使用 const 来声明。 1const [ foo, bar ] = &#123; foo: 1, bar: 2 &#125; 22. 【建议】在样式中 Class 命名可以使用一些常用简写来减少长度。 1234567891011121314151617181920212223242526272829303132333435hd -&gt; headhdr -&gt; headerft -&gt; footftr -&gt; footerpg -&gt; pagebtn -&gt; buttontxt -&gt; textel -&gt; elementopt -&gt; optionbd -&gt; bordercl -&gt; clearfixp -&gt; paddingm -&gt; marginl -&gt; leftr -&gt; rightt -&gt; topb -&gt; bottomx -&gt; horizontaly -&gt; verticalpx -&gt; padding-left, padding-rightpy -&gt; padding-top, padding-bottompl -&gt; padding-leftm -&gt; margindlg -&gt; dialogsel -&gt; selectimg -&gt; imagelbl -&gt; labelchk -&gt; checkboxtpl -&gt; templatetbl -&gt; tablehoz -&gt; horizontalvert -&gt; verticalref -&gt; referencewiz -&gt; wizardoh -&gt; overflow: hidden 补充：有些简写不能单独使用，终须组合才能使用，例如: p, m, x, y等单个词汇。 23. 【建议】在命名时采用 BEM 的方式，并适当变化，具体参见后续文章。 12345.page-header__main.dialog__content.gallery-list--wrap.thumbnail-image--info.action__btn-group 24. 【建议】样式 Class 命名使用中线连接，ID 命名采用下划线连接。Class 可以同时采用中线和下划线，但要遵循一定的规则。 12.thumbnail-item-image#page_header 25. 【参考】样式 Class 采用组合方式，通过外层 Class 名来限制作用范围。 1234567891011// 正例&lt;div class=&quot;page-header&quot;&gt; &lt;div class=&quot;page-header__wrap common&quot;&gt;&lt;/div&gt; &lt;div class=&quot;page-header__wrap tab&quot;&gt;&lt;/div&gt;&lt;/div&gt;// 反例&lt;div class=&quot;page-header&quot;&gt; &lt;div class=&quot;page-header__wrap page-header--common&quot;&gt;&lt;/div&gt; &lt;div class=&quot;page-header__wrap page-header--tab&quot;&gt;&lt;/div&gt;&lt;/div&gt; 补充：这种方式的目的在于减少长度，通过 “主体 + 分类名词” 的方式，可以解释为 “带分类的主体”，但是有一个问题是全局样式要注意不要使用通用的词汇来定义样式，比如 title, action, header, footer, left, right等，不然会引起样式覆盖。 avaScript 作为前端开发从业人员必须掌握的 3 大基础知识中最重要的一环，也是平是接触时间最长、写得最多的。在开发过程中必然会遇到命名的问题，你会词穷、纠结、惆怅吗？本文的出现相信能够解决大部分烦恼，让你轻松写出符合规范、易读、简短的代码。 本文将通过大量的实例来试图自圆其说，形成一套系统化、实用的变量命名理化体系。通过按 JavaScript 的数据类型分类着手、细到一个函数的参数命名，并提供众多可选方案，并尽量给出其适用范围和利弊。 需要注意的是由于个人写作水平、和知识有限，很多方面叙述上有些生硬，在分类上也没有什么特别的依据，文章也没有人审稿，所以有什么纰漏还请留言告知。由于写作仓促，内容可能不全，后续会随着工作和学习的深入而不断地调整和更新。 布尔值(Boolean)命名Boolean 值是两种逻辑状态的变量，它包含两个值：真和假。在 JavaScript 中对应 true 和 false，在实践中通常使用数字1表示真值，0来表示假值。 虽然 Boolean 的状态只有两种但是在命名时可以进一步分类，这里给出几种场景： 场景一：表示可见性、进行中的状态解释：可见性在通常指页面中的元素、组件是否显示（或者组件挂载到 DOM 上，但并不可见）。进行中主要是说明某种状态是处于持续进行中。 推荐命名方式为 is + 动词（现在进行时）/形容词，同时这种方式也可以直接不写 is，但是为了更好的作区分，建议还是加上。 123456789&#123; isShow: &#x27;是否显示&#x27;, isVisible: &#x27;是否可见&#x27;, isLoading: &#x27;是否处于加载中&#x27;, isConnecting: &#x27;是否处于连接中&#x27;, isValidating: &#x27;正在验证中&#x27;, isRunning: &#x27;正在运行中&#x27;, isListening: &#x27;正在监听中&#x27;&#125; 注意： 在 Java 中使用这种方式是有一定副作用的，为什么请移步：为什么阿里巴巴禁止开发人员使用 “isSuccess” 作为变量名？ 场景二：属性状态类解释：通常用来描述实体（例如：HTML 标签、组件、对象）的功能属性，而且定法比较固定。 123456789101112&#123; disabled: &#x27;是否禁用&#x27;, editable: &#x27;是否可编辑&#x27;, clearable: &#x27;是否可清除&#x27;, readonly: &#x27;只读&#x27;, expandable: &#x27;是否可展开&#x27;, checked: &#x27;是否选中&#x27;, enumberable: &#x27;是否可枚举&#x27;, iterable: &#x27;是否可迭代&#x27;, clickable: &#x27;是否可点击&#x27;, draggable: &#x27;是否可拖拽&#x27;&#125; 场景三：配置类、选项类解释：主要是指组件功能的开启与关闭，功能属性的配置。 这是一种比较常见的情景，目前命名方式也有很多种，但是归纳起来也不多。推荐使用 withXx 来表示组件在基本功能形态外的其它功能，比如组件的基础功能到高级功能的开启；使用 enableXx 来表示组件某些功能的开启；使用 allowXx 来表示功能属性的配置；使用 noXx 用于建议功能使用者这个不建议开启。 1234567891011&#123; withTab: &#x27;是否带选项卡&#x27;, withoutTab: &#x27;不带选项卡&#x27;, enableFilter: &#x27;开启过滤&#x27;, allownCustomScale: &#x27;允许自定义缩放&#x27;, shouldClear: &#x27;是否清除&#x27;, canSelectItem: &#x27;是否能选中元素&#x27;, noColon: &#x27;不显示label后面的冒号&#x27;, checkJs: &#x27;检查Js&#x27;, emitBOM: &#x27;Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.&#x27;&#125; 注意：如果嫌分类太多，可以只使用其中一种方式，比如在 Typescript 中使用了 allownXx 和 noXx。 除了上面这些带有特定的前置介词、动词方式外还有一些在语义上带有疑问性质的组合通常也是作为 Boolean 命名的一种参考。 12345&#123; virtualScroll: &#x27;是否启用虚拟滚动模式&#x27;, unlinkPanels: &#x27;在范围选择器里取消两个日期面板之间的联动&#x27;, validateEvent: &#x27;输入时是否触发表单的校验&#x27;&#125; 函数命名函数在不同的上下文中的叫法也不一样，在对象中称为方法，在类中有构造函数、在异步处理时有回调函数，还有立即执行函数、箭头函数、柯里函数等。 函数命名的方式常常是和业务逻辑耦合在一起的，但是在命名规则上也有一些常见的模式可以遵循。 场景一：事件处理事件处理函数是前端平时用到最多的，包括浏览器原生事件、异步事件和组件自定义事件。在写法上最常见的两种命名分别为 onXx、onXxClick和handleXx、handleXxChange。 这里如何在二者之间选择，可以从二方面来归类。一是，原生事件采用 onXx，而自定义事件使用 handleXx。二是，事件主动监听采用 onXx，被动处理使用 handleXx。 从实践及三大主流框架的文档关于事件部分的内容来看，推荐使用 handleXx 这种方式，而在表单提交的时候通常采用 onSubmit 函数。 其实，在实际项目中很少严格这样来命名事件处理函数，因为这种方式有一定的局限性，比如点击按钮打开一个对话框，使用 handleOpenDlg 和 onOpenDlg 都没有直接写 openDlg 方便，如果页面有多个不同功能的对话框采用这种方式会显得变量名过长，而 handle 和 on 就显得没有必要了，比如 hanldeOpenCommentDlg 就没有 openCommentDlg 直白。 下面列出了一些约定成俗的适用例子： 123456&#123; onSubmit: &#x27;提交表单&#x27;, handleSizeChange: &#x27;处理分页页数改变&#x27;, handlePageChange: &#x27;处理分页每页大小改变&#x27;, onKeydown: &#x27;按下键&#x27;&#125; 场景二：异步处理这里主要是指在写数据层服务、状态管理中的 Action 命名，以及 Ajax 回调的命名规则。 123456789&#123; getUsers: &#x27;获取用户列表&#x27;, fetchToken: &#x27;取得Token&#x27;, deleteUser: &#x27;删除用户&#x27;, removeTag: &#x27;移除标签&#x27;, updateUsrInfo: &#x27;更新用户信息&#x27;, addUsr: &#x27;添加用户&#x27;, createAccount: &#x27;创建账户&#x27;&#125; 命名主要围绕数据的增删查找来划分，获取数据通常是 getXx 和 fetchXx，在作者看来两者在使用上的区分在于 getXx 的数据来源不一定直接取自异步的原始数据，可能是加工处理后的，而 fetchXx 是直接拿的原始数据。当然在实际项目中并没有区分，看个人喜好。 deleteXx 主要用于数据删除，而 removeXx 在语义上是移除数据，通常情况数据是还存在的，只是没有显示或数据假删除。updateXx 是指数据更新操作，addXx 是在已有列表数据中添加新的子项、而createXx 主要是创建新的实例，比如新建一个账户。 场景三： 跳转路由在实际开发过种中，比如在使用 react-router&#x2F;vue-router 时，在模板或者 JSX 中可以直接在标签中写上目标地址，但有些时候跳转的目标地址是经过判断或者组合后的，并且通过事件触发跳转的，这个时候就需要一个函数来处理，那么在函数命名的时候可以考虑使用 123456789&#123; toTplDetail: &#x27;跳转到模板详情页面&#x27;, navigateToHome: &#x27;导航到首页&#x27;, jumpHome: &#x27;跳转首页&#x27;, goHome: &#x27;跳转首页&#x27;, redirectToLogin: &#x27;重定向到登录页&#x27;, switchTab: &#x27;切换Tab选项卡&#x27;, backHome: &#x27;回到主页&#x27;&#125; 推荐使用 toXx 和 goXx 这两种方式，如果不是在当前页面打开&#x2F;跳转页面，可以使用 toBlankTplDetail 或者 goBlankHome 这种方式来进一步语义化。如果前端页面是位于 Webview 中，也可以考虑采用 toNativeShare 这种方式来命名。 场景四：框架相关特定方法这里主要是针对前端 3 大主流流行框架，有一些命名是带有特定标识符的，还有就是一些生命周期的命名方式。 123456789101112131415&#123; formatTimeFilter: &#x27;在AngularJs和Vue中，通常用于过滤器命名&#x27;, storeCtrl: &#x27;用于AngularJs定义控制器方法&#x27;, formatPipe: &#x27;用于Angular中，标识管道方法&#x27;, $emit: &#x27;Vue中的实例方法&#x27;, $$formatters: &#x27;AngularJs中的内置方法&#x27;, beforeCreate: &#x27;Vue的生命周期命名&#x27;, componentWillMount: &#x27;React生命周期命名&#x27;, componentDidMount: &#x27;React生命周期命名&#x27;, afterContentInit: &#x27;Anuglar生命周期命名&#x27;, afterViewChecked: &#x27;Angula生命周期命名&#x27;, httpProvider: &#x27;AngularJs服务&#x27;, userFactory: &#x27;工厂函数&#x27;, useCallback: &#x27;React钩子函数&#x27;&#125; 场景五：数据的加工这类场景在处理列表的时候经常会碰到，比如排序、过滤、添加额外的字段、根据 ID 和索引获取特定数据等。 情形一：根据特定属性获取属性这里可以参考 DOM 方法的命名，比如：getElememtById()、getElementsByTagName()、getElementsByClassName() 和 getElementsByName()，然后提炼出一个比较实用的模板：getXxByYy()。其中 Xx 可以是：element, item, option, data, selection, list, options 以及一些特定上下文的名字，比如：user(s), menu(s) 等。Yy 相对来说比较固定，经常用到的就是 id, index, key, value, selected, actived 等。 除了使用 get，还可以使用 query 和 fetch，但是需要注意和上面提到的异步数据处理作一个区分。 12345&#123; getItemById: &#x27;根据ID获取数据元素&#x27;, getItemsBySelected: &#x27;根据传入的已选列表ID来获取列表全部数据&#x27;, queryUserByUid: &#x27;根据UID查询用户&#x27;&#125; 注意：在 getItemsBySelected 这种情形下直接写成 getItemsSelected 更好，但只适用于 Yy 为形容词的场景 情形二：格式化数据这里的格式化操作包括排序、调整数据结构、过滤数据、添加属性。命名通常使用 formatXx, convertXx, inverseXx, toggleXx, parseXx, flatXx, 也可以结合数组的一些操作方法来命名，比如 sliceXx, substrXx, spliceXx, sortXx, joinXx 等来命名。 123456789&#123; formatDate: &#x27;格式化日期&#x27;, convertCurrency: &#x27;转换货币单位&#x27;, inverseList: &#x27;反转数据列表&#x27;, toggleAllSelected: &#x27;切换所有已选择数据状态&#x27;, parseXml: &#x27;解析XML数据&#x27;, flatSelect: &#x27;展开选择数据&#x27;, sortByDesc: &#x27;按降序排序&#x27;&#125; 数组命名数组的命名推荐使用复数形式来命名，还有就是名词和具有列表意思的单词组合。常见的词汇有 options, list, maps, nodes, entities, collection 等。 123456789&#123; users: &#x27;用户列表&#x27;, userList: &#x27;用户列表&#x27;, tabOptions: &#x27;选项卡选项&#x27;, stateMaps: &#x27;状态映射表&#x27;, selectedNodes: &#x27;选中的节点&#x27;, btnGroup: &#x27;按钮组&#x27;, userEntities: &#x27;用户实体&#x27;&#125; 选项元素、下拉元素命名主要针对的是在下拉选择框、选项卡元素、Radio、Checkbox 等数据源每个选项数据的命名。常见的词汇有：title, name, key, label, field, value, id, children, index, nodes 等。 基中 title/name/key/label/field 作为选项显示名, value/id 用于唯一标识选项，children/nodes 用于包含子节点内容。如果选项元素的语义很明确的情况下也可以直接使用特定单词来代替提到的这些泛指的词汇，例如菜单列表就可以使用 menu 来作为显示名。 &#x2F;&#x2F; 最常见组合 1234567891011121314151617181920212223&#123; title: &#x27;标题&#x27;, value: &#x27;ID值&#x27;&#125;// 组合二&#123; label: &#x27;标签名&#x27;, value: &#x27;ID值&#x27;&#125;// 组合三&#123; name: &#x27;元素名&#x27;, id: &#x27;ID值&#x27;&#125;// 组合四&#123; field: &#x27;字段&#x27;, value: &#x27;标识&#x27;, index: &#x27;索引&#x27;&#125; 当前选项、激活项命名适用列表的选中项、菜单选中项、步骤操作的当前进行步骤、页面路由当前路由等的命名。 12345&#123; activeTab: &#x27;当前选中选项卡&#x27;, currentPage: &#x27;当前页&#x27;, selectedData: &#x27;当前选项中数据&#x27;,&#125; 临时数据、比对数据命名针对在代码中有时会使用一些临时的变量来存储数据、保存数据快照的场景下的命名。 12345&#123; swapData: &#x27;临时交换数据&#x27;, tempData: &#x27;临时数据&#x27;, dataSnapshot: &#x27;数据快照&#x27;&#125; 数据循环语句中变量命名在使用 for 循环时，多层嵌套请依次使用 i/j/k，超过 3 层可以使用 x/y/z，m/n 来命名。使用 forEach, map, filter 等方法时，每一个元素命名可以根据不同语境下的特殊名字来命名，比如遍历 menus，那么每个元素可以命名为 menu，不然则使用上下文无关的词汇，比如：item, option, data, key, object 等。至于索引通常使用 index，如果多层可以使用 index + 数字 的形式，也可以直接使用 i/j/k 来作为索引，甚至还可以使用 subIndex/grandIndex 这种方式来命名。 对于在使用 for 循环时数组长度如果需要单独命名的话，可以使用 xxlength/xxLens，或者 xxCount。 在循环的过程中通常还会统计某个条件下数据匹配的次数、重复元素数量、记录中间结果等情况。这里推荐使用 count 表示次数，skipped 表示跳过的数量，result 表示结果。 1234567891011121314151617181920212223242526272829// for 循环for (let i = 0; i &lt; 10; i++) &#123; for (let j = 0; j &lt; 10; j++) &#123; for (let k = 0; k &lt; 10; k++) &#123; // do something &#125; &#125;&#125;for (let i = 0, lens = this.options.length; i &lt; lens; i++) &#123; // do something&#125;// forEachusers.forEach((item, index) =&gt; &#123; // do something&#125;)menus.forEach((menu, index) =&gt; &#123; if (menu.children) &#123; menu.children.forEach((subMenu, subIndex) =&gt; &#123; if (subMenu.children) &#123; subMenu.children.forEach((grandMenu, grandIndex) =&gt; &#123; // 一个不常用的示例 &#125;) &#125; &#125;) &#125;&#125;) 方法参数命名方法的参数名称和数量在不同的方法中各不相同，但是还是有一些固定的模式可以参考，比如在 Vue 中监听属性变化的新值和旧值；reduce 方法的上一个值，当前值；回调函数的命名、剩余参数的命名等。 情形一：新值、旧值常见于 Vue 中watch 对像中的属性监听回调函数，推荐使用 1234&#123; oldVal: &#x27;旧值&#x27;, newVal: &#x27;新值&#x27;&#125; 情形二：上一个值、下一个值和当前值这种情形见于路由的钩子方法，Object.assign 数据拷贝的参数。 123456789101112131415161718192021222324// 组合一&#123; from: &#x27;从...&#x27;, to: &#x27;到...&#x27;&#125;// 组合二&#123; prev: &#x27;上一个...&#x27;, next: &#x27;下一个...&#x27;, cur: &#x27;当前&#x27;&#125;// 组合三&#123; source: &#x27;源&#x27;, target: &#x27;目标&#x27;&#125;// 组合四&#123; start: &#x27;开始&#x27;, end: &#x27;结束&#x27;&#125; 情形三：异步数据返回用于 Promise 的then方法参数，await 的返回的 Promise 等。可选择的词汇有：res, data, json, entity，推荐使用 res。 123demoPromise.then(res =&gt; &#123; // do something&#125;) 情形四：其它情况一些使用不多，但是在编程时约定成俗的命名方式。例如 ch 表示单个字符，str 表示字符串, n 代表次数, reg 表示正则, expr 表示表达式, lens 表示数组长度, count 表示数量, p 表示数据的精度, q 表示查询(query), src 表示数据源(source), no 表示数字(number), rate 表示比率, status 表示状态, bool 表示布尔值, arr 表示数组值, obj 表示对象值, x 和 y 表示坐标两轴, func 表示函数, ua表示 User Agent, size 表示大小, unit 表示单位, hoz 表示水平方向, vert 表示垂直方向, radix 表示基数，根 12345678// 传入单个字符function upper(ch) &#123;&#125;// 数量重复function repeat(str, n)// 正则&#x27;abab&#x27;.replace(reg, &#x27;bb&#x27;) 事件命名这里根据 DOM、nodejs 和一些框架和 UI 组件的事件进行归纳 DOM 事件这里列举 DOM 中常见的事件命名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; load: &#x27;已完成加载&#x27;, unload: &#x27;资源正在被卸载&#x27;, beforeunload: &#x27;资源即将被卸载&#x27;, error: &#x27;失败时&#x27;, abort: &#x27;中止时&#x27;, focus: &#x27;元素获得焦点&#x27;, blur: &#x27;元素失去焦点&#x27;, cut: &#x27;已经剪贴选中的文本内容并且复制到了剪贴板&#x27;, copy: &#x27;已经把选中的文本内容复制到了剪贴板&#x27;, paste: &#x27;从剪贴板复制的文本内容被粘贴&#x27;, resize: &#x27;元素重置大小&#x27;, scroll: &#x27;滚动事件&#x27;, reset: &#x27;重置&#x27;, submit: &#x27;表单提交&#x27;, online: &#x27;在线&#x27;, offline: &#x27;离线&#x27;, open: &#x27;打开&#x27;, close: &#x27;关闭&#x27;, connect: &#x27;连接&#x27;, start: &#x27;开始&#x27;, end: &#x27;结束&#x27;, print: &#x27;打印&#x27;, afterprint: &#x27;打印机关闭时触发&#x27;, click: &#x27;点击&#x27;, dblclick: &#x27;双击&#x27;, change: &#x27;变动&#x27;, select: &#x27;文本被选中被选中&#x27;, keydown/keypress/keyup: &#x27;按键事件&#x27;, mousemove/mousedown/mouseup/mouseleave/mouseout: &#x27;鼠标事件&#x27;, touch: &#x27;轻按&#x27;, contextmenu: &#x27;右键点击 (右键菜单显示前)&#x27;, wheel: &#x27;滚轮向任意方向滚动&#x27;, pointer: &#x27;指针事件&#x27;, drag/dragstart/dragend/dragenter/dragover/dragleave: &#x27;拖放事件&#x27;, drop: &#x27;元素在有效释放目标区上释放&#x27;, play: &#x27;播放&#x27;, pause: &#x27;暂停&#x27;, suspend: &#x27;挂起&#x27;, complete: &#x27;完成&#x27;, seek: &#x27;搜索&#x27;, install: &#x27;安装&#x27;, progress: &#x27;进行&#x27;, broadcast: &#x27;广播&#x27;, input: &#x27;输入&#x27;, message: &#x27;消息&#x27;, valid: &#x27;有效&#x27;, zoom: &#x27;放大&#x27;, rotate: &#x27;旋转&#x27;, scale: &#x27;缩放&#x27;, upgrade: &#x27;更新&#x27;, ready: &#x27;准备好&#x27;, active: &#x27;激活&#x27;&#125; 自定义事件在封装组件时提供的事件名除了参考 DOM 事件外，在命名上也可以参考 Github Api 采用 动词过去时 + Event 的方式, Visual Studio Code Api 的 &#96;on + 1234567&#123; assignedEvent: &#x27;分配事件&#x27;, closedEvent: &#x27;关闭事件&#x27;, labeledEvent: &#x27;标签事件&#x27;, lockedEvent: &#x27;锁事件&#x27;, deployedEvent: &#x27;部署事件&#x27;&#125; 此外，很多命名方式可以根据场景使用 元素 + click 、元素 + change 、select + 范围等方式灵活运用 12345&#123; selectAll: &#x27;选择所有&#x27;, cellClick: &#x27;当某个单元格被点击时会触发该事件&#x27;, sortChange: &#x27;当表格的排序条件发生变化的时候会触发该事件&#x27;&#125; 状态管理命名如果在项目中用到了状态管理(redux&#x2F;vuex&#x2F;ngrx)，下面给出一些 ActionType，Mutation, Action 的命名参考。 12345678910111213// Redux 的 actionTypeLOAD_SUCCESSLOAD_FAILTOGGLE_SHOW_HISTORYON_PLAYON_LOAD_STARTFETCH_SONGS_REQUESTRECEIVE_PRODUCTS// ngrxconst SET_CURRENT_USER = &#x27;[User] Set current&#x27;;const ADD_THREAD = &#x27;[Thread] Add&#x27;;const UPDATE_TRIP_SUCCESS = &#x27;Update [Trip] Success&#x27;; 其它命名123456789// 日期、时间// --------------------------------------------------------sentAt: &#x27;发送时间&#x27;addAt: &#x27;添加时间&#x27;updateAt: &#x27;更新时间&#x27;startDate: &#x27;开始日期&#x27;endDate: &#x27;结束日期&#x27;startTime: &#x27;开时时间&#x27;endTime: &#x27;结束时间&#x27; 本文主要为广大前端开发人员提供一个英文词汇参考，便于记忆和查阅。文中内容按照特定的方式进行分类便于读者关注感兴趣的部分。 文中的单词并没有给出其词性，很多词性的变化需要读者具备一定的英语语法知识，以便在特定情况下灵活运用。 数字数字部分包含英文的数字表示、数字运算符、数字单位 infinite: 无限的 英文数字123456789101112131415161718192021222324252627282930zero: 零one: 一two: 二three: 三four: 四five: 五six: 六seven: 七eight: 八nine: 九ten: 十eleven: 十一twelve: 十二thirteen: 十三fourteen: 十四fifteen: 十五sixteen: 十六seventeen: 十七eighteen: 十八nineteen: 十九twenty: 二十thirty: 三十forty: 四十fifty: 五十eighty: 八十ninety: 九十hundred: 百thousand: 千million: 百万billion: 十亿 计数单位12pixel: 像素percent: 百分比 &#x2F;&#x2F; 中文数字 123456ten: 十hundred: 百thousand: 千ten thousand: 万billion: 亿trillion: 兆 &#x2F;&#x2F; 存储容量 12345byte: 字节 Bkilobyte: 千字节 KBmegabyte 兆字节 MBgigabyte 吉字节 GBtrillionbyte 太字节 TB 进制1234decimal: 十进制hex: 十六进制binary: 二进制octal: 八进制 运算符123456789add: 加subtract: 减multiply: 乘divide: 除and: 与or: 或not: 非intersection: 交集compose: 并集 键盘符号12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758punctuator: 标点符号identifier: 标识符// Unique graphic character allocations// 独特的图形字符分配// --------------------------------------------------------exclamation mark: ! 感叹号quotation mark: &quot; 双引号percent sign: % 百分号ampersand: &amp; and符号apostrophe: &#x27; 撇号ellipse/apostrophe: …… 省略号left parenthesis: ( 左括号right parenthesis: ) 右括号asterisk: * 星号plus sign: + 加号comma: , 逗号slight-pause mark: 、 顿号hyphen-minus: - 连字符(-) 或者 减号(-)full stop: . 句号middle dot: ・ 中间点interpunct: · 间隔号hyphenation point: · 连字点solidus: / 斜线colon: : 冒号semicolon: ; 分号less-than sign: &lt; 小于符号equals sign: = 等于符号greater-than sign: &gt; 大于符号question mark: ? 问号low line: _ 下划线digital 0: 0 数字 0latin capital letter A: A 大写拉丁字母latin small letter A: A 小写拉丁字母// Alternative graphic character allocations// 可选的图形字符分配// --------------------------------------------------------number sign: # 数字符号pound sign: £ 英镑符号dollar sign: $ 美元符号currency sign:  货币符// IRV(International Reference Version) graphic character allocations// IRV图形字符分配// --------------------------------------------------------number sign: # 数字符号dollar sign: $ 美元符号commercial at: @left square bracket: [ 左方括号reverse solidus: 反斜线right square bracket: ] 右方括号circumflex accent: ^ 抑扬音符号grave accent: ` 沉音符left curly bracket: &#123; 左花括号vertical line: | 垂直线right curly bracked: &#125; 右花括号tilde: ~ 波浪符 说明：由于标点符号中英文语言环境同一个符号也不同叫法别名，因此上面列举的词汇只能说涉及到了部分，并没有把所有 Dialect(方言) 包含进来。 注：· 符号在不同的上下文中有不同的叫法，比如“间隔号”、“中间点”、“项目符号”、“连子点”等，虽然肉眼看起来没有什么大的区别，但是在计算机中的 Unicode 编码是不一样的，更多参见间隔符 时间、日期下面虽然列举了很多时间相关的词汇，但是在实际前端开发过程中用到的就年、月、日和时、分、秒、毫秒。 123456789101112131415161718192021222324252627282930313233343536373839time: 时间date: 日期workday: 工作日weekend: 周末season: 季节anniversary: 周年century: 世纪；百年quarter: 一刻钟holiday: 节日；假日morning: 上午noon/midday: 中午afternoon: 下午night: 晚上midnight: 半夜yesterday: 昨天today: 今天tomorrow: 明天clock: 时钟now: 现在；如今；立刻nowadays: 现今；时下present: 现在（的）former: 从前的；前任的before: 在...之前after: 在...之后future: 将来permanent: 永久的；不变的period: 周期；期间；一段时间during: 在...的期间；在...期间的某个时候term: 学期；期限early: 早期的，提早；在初期ahead: 在前的；领先的；提前的later: 后来；稍后；随后start/begin: 开始end: 结束pause: 暂停suspend: 推迟；使暂停timeout: 超时；暂时休息；工间休息interval: 间隔overtime: 超时的；加班的，加班时间 时间12345678year: 年month: 月day: 日week: 周hour: 小时minute: 分seconds: 秒millisecond: 毫秒 星期1234567Monday: 星期一Tuesday: 星期二Wednesday: 星期三Thursday: 星期四Friday: 星期五Saturday: 星期六Sunday: 星期日 月份123456789101112January: 一月February: 二月March: 三月April: 四月May: 五月June: 六月July: 七月August: 八月September: 九月October: 十月November: 十一月December: 十二月 季节1234spring: 春季summer: 夏季autumn: 秋季winter: 冬季 地理位置1234567891011121314151617map: 地图location: 地理位置place: 地方earth: 地球province: 省city: 市district: 区area: 区域、范围region: 地区、范围、部位address: 地址edges: 边界boundary: 边界；范围；分界线coordinate: 坐标east: 东south: 南west: 西north: 北 方位123456789direction: 方向position: 位置top: 上right: 右bottom: 下left: 左opposite: 对面的center: 中间（水平）middle: 中间（垂直） 排版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647abstract: 摘要annex: 附录suffix: 后缀；词尾prefix: 前缀titl: 标题summary: 总结；概要specifications: 规范headline: 大标题；内容提要；栏外标题preface: 前言；引语；序言chapter: 章；篇；回section: 章节；部分abbreviation: 缩写；缩写词font: 字体color: 颜色heading: 标题align: 对齐align left/align center/align right: 左对齐/居中对齐/右对齐align top/align middle/align bottom: 顶对齐/垂直居中/底部对齐text: 文本zoom: 放大size: 大小opacity: 透明度position: 位置rotation: 旋转fill: 填充shadow: 阴影blur: 模糊filter: 滤镜radius: 圆角unite: 合并subtract: 差集intersect: 交集exclude: 排除join: 合并insert image: 插入图片code: 插入代码highlight: 高亮strikethrough: 删除线underscore: 下划线italic: 斜体bold: 粗体horizontal line: 水平分隔线attach file: 附加文件checklist: 清单列表bullet: 项目符号indention: 缩进 形状12345678910111213141516171819figure: 图形stroke: 描边fill: 填充border: 边框line: 线rectangle: 矩形ellipse: 椭圆sphere: 球triangle: 三角形sector: 扇形annulus: 圆环trapezium: 梯形polygon: 多边形arch: 弓形circle: 圆、循环、周期star: 星形、评分cylinder: 圆柱circle cone: 圆锥love: 爱心 语法123456789101112131415161718192021222324252627282930313233343536373839grammar: 语法syntax: 句法morphology: 词法structure: 结构sentence: 句子clause: 从句phrase: 词组word: 单词adjective: 形容词verb: 动词noun: 名词abstract noun: 抽象名词pronouns: 代词determiner: 限定词conjunction: 连词interjection: 感叹词adverb: 副词preposition: 介词；前置词derivative: 派生词numeral: 数词auxiliary: 助动词tense: 时态passive: 被动语态gerund: 动名词antonym: 反义词article: 冠词antecedent: 先行词regular/irregular verbs: 规则╱不规则动词transitive/intransitive verbs: 及物╱不及物动词subject: 主语object: 宾语predicate: 谓语；表语adverbial: 状语complement: 补语appositive: 同位语adjunct: 修饰语affix: 词缀acronym: 首字母缩略词abbreviation: 缩写词 常用颜色123456789101112131415161718192021pink: 粉红violet: 紫罗兰magenta: 洋红(玫瑰红)purple: 紫色blue: 纯蓝azure: 蔚蓝色cyan: 青色green: 纯绿lime: 闪光绿ivory: 象牙色yellow: 纯黄olive: 橄榄gold: 金色orange: 橙色snow: 雪白色red: 纯红brown: 棕色white: 纯白sliver: 银灰色gray: 灰色black: 纯黑 JavaScript 语言相关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139type: 数据类型primitive type: 原始类型object: 对象array: 数组string: 字符串boolean: 布尔值symbol: 符号undefined: 未定义null: 空function: 函数array function: 箭头函数curried function: 柯里函数callback: 回调函数class: 类module: 模块import: 导入export: 导出constructor: 构造函数prototype: 原型reference: 引用closure: 闭包destructure: 解构variable: 变量property: 属性attribute: 特性iterator: 迭代器generator: 生成器yield: 产出observable: 可观赛的hosit: 提升operator: 运算符equal: 相等statement: 语句block: 块comment: 注释whitespace: 空格event: 事件listener: 监听器accessor: 访问器decorator: 装饰器proxy: 代理reflect: 反射promise: 承诺test: 测试fetch: 拿；取descriptor: 描述符号sync: 同步async: 异步await: 等候find: 查找every: 所有some: 部分foreach: 为每一个map: 遍历filter: 过滤pad: 填充index: 索引data: 数据slice: 把...分成部分splice: 拼接，接合reduce: 归纳push: 推pull: 拉pop: 弹出split: 分离join: 连接flatten: 变平replace: 替换search: 搜索scope: 作用域timeout: 超时interval: 间隔value: 值define: 定义math: 数学sum: 求和configurable: 可配置enumerable: 可枚举writable: 可写local: 局部的global: 全局的not: 非or: 或xor: 异或and: 且regexp: 正则表达式match: 匹配pattern: 模式greed: 贪婪color: 颜色rest: 剩余assign: 赋值tag: 标签buffer: 缓冲区super: 极好的extend: 扩展readonly: 只读override: 重写dynamic: 动态的；多态default: 默认的implement: 实现；执行strict: 严格的deprecate: 不推荐；反对tab: 制表符space: 空格indentation: 缩进public: 公共的private: 私有的namespace: 命名空间member: 成员method: 方法parameter/argument: 参数instance: 实例ternary: 三目运算literary: 字面量template: 模板character: 字符markup: 标记syntax: 语法equality: 相等conditional statements: 条件判断语句true: 是false: 否type-checker: 类型检查compile-time: 编译时lexical scope: 词法作用域static scope: 静态作用域loop: 循环notation: 符号operand: 操作数；运算对象ordinary object: 普通对象standard object: 标准对象built-in object: 内置对象exotic object: 外来对象last-in/first-out manner: 后进先出的方式reserved word: 保留单词signature: 签名enumerable: 可枚举的iterable: 可迭代的 常用简写简写后面用 ”*“ 号标注的为推荐使用简写，可以放心大胆在项目中使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071hd -&gt; headhdr -&gt; headerbd -&gt; bodyft -&gt; footftr -&gt; footertbl -&gt; tableel -&gt; element **cnt -&gt; contentcmp -&gt; componentbtn -&gt; button **sel -&gt; select *opt -&gt; option *chk -&gt; checkboxlbl -&gt; labelwiz -&gt; wizard *bg -&gt; background **cur -&gt; current **prev -&gt; previous **idx -&gt; indexlen -&gt; length **pg -&gt; pagevm -&gt; view pagerepo -&gt; repository *org -&gt; organization *ref -&gt; reference *res -&gt; response **req -&gt; request **msg -&gt; message **str -&gt; string **ch -&gt; chracter *lbl -&gt; labelimg -&gt; image **buf -&gt; buffer *usr -&gt; userargs -&gt; arguments *no -&gt; numbererr -&gt; error *tmp/temp -&gt; temporary **rst -&gt; resultbdr -&gt; borderfn/func -&gt; function **nav -&gt; navigator *val -&gt; valueparams -&gt; parameter *dev -&gt; development *prod -&gt; product *util -&gt; utility *hoc -&gt; high order component *cb -&gt; callback *lib -&gt; library *prop(s) -&gt; property(ies) *attr(s) -&gt; attribute(s) *arr -&gt; array *conf -&gt; config *dlg -&gt; dialoge/ev/evt -&gt; event **pkg -&gt; package *tpl -&gt; template *addr -&gt; addressdesc -&gt; descendingaesc -&gt; aescendingexpr -&gt; expression **src -&gt; source **hoz -&gt; horizontalvert -&gt; verticalabbr -&gt; abbreviateenv -&gt; envirnment **sec -&gt; seconds *ms -&gt; millisecond **bool -&gt; boolean *dbl -&gt; double 常用词汇及其变体1234567891011121314151617181920active -&gt; inactive -&gt; deactiveload -&gt; preload -&gt; unloadcoming -&gt; incomingwith -&gt; withoutsync -&gt; asyncallowed -&gt; unallowedgoing -&gt; ingoing -&gt; ongoingonline -&gt; offlinevisible -&gt; invisiblefinite -&gt; infiniteable -&gt; enabled -&gt; unable -&gt; disabledlogin -&gt; logoutsingin -&gt; signoutcheck -&gt; uncheckselect -&gt; unselectinlet -&gt; outletregular -&gt; irregularimplicit -&gt; explicitimport -&gt; exportmicro -&gt; macro 专用名词缩写1234567891011121314151617GUI -&gt; Graphical User Interface 图形用户界面OEM -&gt; Original Equipment manufacturer 原始设备制造商CMS -&gt; Content Manager System 内容管理系统PWA -&gt; Progressive Web App 渐近式Web应用SDK -&gt; Software Development Kit 软件开发工具包IDE -&gt; Integrated Development Envirnment 集成开发环境SOA -&gt; Service-Oriented Architecture 面向服务架构ORM -&gt; Object Relation Mapping 对象关系映射MVC -&gt; Model View ControllerOOP -&gt; Object Oriented programing 面向对象编程BEM -&gt; Block Element Modifier 块-元素-修饰符BFC -&gt; Block Format ContextSKU -&gt; Stock Keeping Unit 库存单位AJAX -&gt; Asynchronous JavaScript andHOC -&gt; High Order Component 高阶组件I18N -&gt; Internationalization 国际化GUID -&gt; Globally Unique Identifier 全球唯一标识符 UI 组件相关参考 Element、Antd、Bootstrap 和 Material Design &#x2F;&#x2F; 通用 123456789101112131415Head: 标题Label: 标签Button: 按钮Icon: 图标Link: 文字链接Input: 输入框Checkbox: 筛选框Radio: 单选框Select: 下拉选择框Switch: 开关Upload: 文件上传Form: 表单Radio: 音频Video: 视频Canvas: 画布 &#x2F;&#x2F; 布局 123Layout: 布局Grid: 网格；栅格Container: 布局容器 &#x2F;&#x2F; 导航 123456789Affix: 固钉Breadcrumb: 面包屑Dropdown: 下拉菜单Menu: 导航菜单Pagination: 分页PageHeader: 页头Steps: 步骤条NavMenu: 导航菜单Minimap: 小地图 &#x2F;&#x2F; 数据录入 12345678910111213AutoComplete: 自动完成Cascader: 级联选择框DatePicker: 日期选择框TimePicker: 时间选择框DateRangePicker: 日期区间选择框ColorPicker: 颜色选择框InputNumber: 数字输入框Mentions: 提及Rate: 评分Slider: 滑动输入条；滑块TreeSelect: 树选择器Transfer: 穿梭框Wizard: 向导 &#x2F;&#x2F; 数据展示 123456789101112131415161718192021Avatar: 头像Badge: 徽标数Comment: 评论Collapse: 折叠面板Carousel: 走马灯；轮播Card: 卡片Panel: 面板Calender: 日历Descriptions: 描述列表Empty: 空状态List: 列表Popover: 气泡卡片Statistic: 统计数值Tree: 树形控件Tooltip: 文字提示Timeline: 时间轴Tag: 标签Tabs: 标签页InfiniteScroll: 无限滚动Chips: 芯片Dialog: 对话框 &#x2F;&#x2F; 反馈 1234567891011Alert: 警告提示Drawer: 抽屉Modal: 对话框Message: 全局提示MessageBox: 弹框Notification: 通知提醒框Progress: 进度条Popconfirm: 气泡确认框Result: 结果Spin: 加载中Skeleton: 骨架屏 &#x2F;&#x2F; 其它 1234Anchor: 锚点BackTop: 回到顶部Divider: 分隔线ConfigProvider: 全局化配置 &#x2F;&#x2F; Button 尺寸 12345678// --------------------------------------------------------mini: 微型的；袖珍的tiny: 微小的；很少的micro: 极小的；基本的；微小的；微观的small: 小medium: 中等large: 大fixed: 固定宽度的 &#x2F;&#x2F; Button 外观 123456789101112131415// --------------------------------------------------------default: 默认的plain: 朴素的primary: 主要的info: 信息的warning: 警告的error: 错误的danger: 危险的gray: 灰色的link: 带链接的outline: 带轮廓的dashed: 带虚线的round: 带圆角的circle: 圆形的ghost: 幽灵的 &#x2F;&#x2F; 表单控件验证状态 1234567// --------------------------------------------------------valid: 有效的invalid: 无效的pending: 验证中required: 必填的dirty: 脏的pristine: 干净的 代码常用词汇下面列出开发过种中经常使用的动词、名词、介词、形容词。这些词汇通常可以相互组合在特定上下文中适当变动可以覆盖工作中的绝大多数场景。 &#x2F;&#x2F; 动词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105on: 监听、正在进行中get: 取set: 设置fetch: 获取find: 查找add: 添加create: 创建remove: 移除delete: 删除update: 更新upgrade: 升级downgrade: 使降级sync: 同步toggle: 切换pull: 拉push: 推show: 显示hide: 隐藏resolve: 解析；分解parse: 解析lock: 锁定link: 连接merge: 合并close: 关闭clone: 克隆clear: 清除format: 格式化convert: 转变cancel: 取消accept: 承认；同意check: 检查，核对concat: 合并数组、字符串join: 合并split: 分开spread: 展开search: 搜索sort: 排序assign: 分配，指定handle: 处理trigger: 触发login: 登入logout: 登出register: 注册sign: 签名throw: 抛出load: 加载preload: 加载copy: 复制paste: 粘贴connect: 连接change: 改变select: 选择validate: 验证submit: 表单提交commit: 提交match: 匹配scroll: 滚动write: 写read: 读enable: 启用disable: 禁用limit: 限制bootstrap: 启动init: 初始化install: 加载upload: 上传inject: 注入provide: 提供exit: 退出access: 访问flush: 刷新/使暴露refresh: 刷新release: 发布preview: 预览；试映publish: 出版；发行navigate: 导航；浏览redirect: 重定向back: 返回switch: 切换launch: 加载browse/visit: 浏览append: 追加insert: 插入swap: 交换map: 遍历extract: 提取；选取provide: 提供inject: 注入observe: 观察render: 渲染debug: 调试align: 对齐popup: 弹出transfer: 转让、迁移attach: 附加build: 构建diagnose: 诊断，断定ignore: 忽略deploy: 部署；展开send/sent: 送；寄出defer: 推迟delegate: 委托destroy: 销毁dispatch: 派发；分派trace: 追踪 &#x2F;&#x2F; 名词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200avatar: 头像brand: 品牌record: 记录issue: 问题project: 项目repo(repository): 仓库；知识库ecosystem: 生态系统assets: 资产resource: 资源toolkit: 工具包、工具箱workbench: 工作台item: 项目；条款option: 选项field: 字段type: 类型status: 状态property: 属性attribute: 特性parameter/argument: 参数length: 长度size: 尺寸shape: 形状label: 标签value: 值view: 视图page: 页面env(envirnment): 环境context: 上下文count: 总数；计数amount: 数量；数额sum: 合计；金额num(number): 号码total: 总数money: 钱；货币filter: 过滤器pipe: 管道stream: 流buffer: 缓冲器comment: 评论ref(reference): 引用res(response): 响应req(request): 请求entity: 实体event: 事件setup 设置prefix 前缀suffix 后缀wizard 小部件model 模型flag 标志factory 工厂service 服务constant: 常量var(iable): 变量collection: 集合array: 数组raw: 原始值platform 平台capital: 大写字母uppercase/lowercase: 大/小写letter: 字母entrance: 入口path: 路径route: 路由router: 路由器config: 配置middleware: 中间件success: 成功error: 错误fail(ure): 失败frontend: 前端backend: 后端local: 本地sever: 服务器production: 线上；产品border: 边框outline: 轮廓precision: 精度separator: 分隔符mask: 遮罩metadata: 元数据location: 位置sandbox: 沙箱scope: 作用域queue: 队列heap: 堆notice: 通知bubble: 气泡hooks: 钩子cell: 单元格row: 行column: 列group: 组cursor: 游标pattern: 模式abstract: 抽象compose: 复合；并集callback: 回调函数priority: 优先级grade/rank/hierarchy 等级、层级table,chart, graph, diagram: 表格，图表，曲线图，图表system: 系统、体系guards: 保障、守卫segment/fragment: 片段、碎片shaking: 抖动mix: 混淆dependence: 依赖injection: 注入markup: 标记email: 电子邮件version: 版本detail: 详情stub: 存根score: 成绩breakpoint: 断点record: 记录pointer: 指针thumbnail: 缩略图gallery: 画廊viewport: 视口strategy: 策略outlet: 出口inlet: 入口gist: 主旨；要点；依据licence: 许可证copyright: 版权order: 命令input: 输入output: 输出effect: 影响；效果；作用position: 位置corner: 角落animation: 动画dot: 点palette: 调色板；颜料album: 相册photo: 照片host: 主机session: 会话cookie: 饼干；小甜点domain: 域名certificates: 证书coercion: 强制payload: 载物thread: 线程process: 进程timestamp: 时间缀conflicts: 冲突terminal: 终端portrait: 肖像auxiliary: 附属物backup: 备份bitmap: 位图breakpoint: 断点concurrency: 并发lock: 锁digest: 摘要exception: 异常genericity: 泛型handle: 句柄macro: 宏manifest: 清单modifier: 修饰字；修饰符override: 覆写overload: 重载procedure: 过程protocol: 协议recursion: 递归marquee: 跑马灯// 形容词native: 原生的hybrid: 混合的basic: 基础的complex: 复杂的empty: 空的online: 在线的offline: 离线的public: 公共的private: 私有的static: 静态的dynamic: 动态的shared: 共享的safe: 安全的relative: 相对的absolute: 绝对的original: 原始的infinite: 无限的partial: 局部的ascending: 按升序descending: 按降序primary: 原始的，第一的secondary: 第二的tertiary: 第三的deprecated: 弃用的concrete: 具体的abstract: 抽象的explicit: 显示的；明确的implicit: 含蓄的；暗示的mutable: 可变的 业务常用词汇电商123456789101112131415161718192021222324252627282930coupons: 优惠券couponsCode: 优惠码discount: 折扣points: 积分memeber: 会员vip: 会员membership: 会员delivery: 运费domain: 域名dashboard: 仪表盘store: 门店shop: 店铺product: 产品goods: 商品order: 订单setting: 设置manager: 管理channel: 渠道notFound: 404页面feedback: 反馈scratch: 刮刮卡client: 客户端market: 市场promotion: 促销popularize: 推广tool: 工具banner: 广告friendlink：友情链接partner： 合作伙伴vote: 投票 技术文章阅读常用词汇&#x2F;&#x2F; 副词 12345approximately: 大约；近似地；近于indirectly: 间接地；迂回地inevitably:不可避免地；必然地repeatedly: 反复地；再三地defiantly: 挑战地；对抗地 &#x2F;&#x2F; 形容词 123456789101112131415161718general: 一般的；普通的；大体的partial: 局部的well-formed：符合语法规则的appropriate: 适当的；恰当的；合适的reasonable: 合理的；公道的non-trivial: 非平凡的conditional: 有条件的；假定的disheartened: 沮丧的；灰心的unmotivated: 对（工作等）不感兴趣的；没有理由的terse: 简洁的；精练的；扼要的chaotic: 混沌的；混乱的，无秩序的effective: 有效的discursive: 离题的；东拉西扯的；无层次的impressive: 感人的；令人钦佩的；给人以深刻印象的error-prone: 于出错的weird: 怪异的；不可思议的；超自然的hypothetical: 假设的；假定的tricky: 狡猾的；机警的；棘手的 事件 123456789Onmouseover 鼠标移到目标上；鼠标移进时Onclick 鼠标单击Onmouseout 鼠标移出时onkeyup 键抬起时onkeydown 键按下时blur vt. 涂污；使…模糊不清；使暗淡；玷污n. 污迹；模糊不清的事物onblur 失去焦点,数组常用方法push 推动，增加；对…施加压力，逼迫；按；说服filter “n. 滤波器；[化工] 过滤器；筛选；滤光器vt. 过滤；渗透；用过滤法除” 运算单词 123456789101112131415161718192021222324252627282930plus（表示运算）加;加的; 正的; 附加的; 比所示数量多的;minus（表示运算）减去; 减号; 负号; 不利; 不足;multiply 乘; （使）相乘; （使）增加; （使）繁殖;quotient 商，商数，系数divide(by) 分开，除DOM操作部分replace vt. 取代，代替；替换，更换；归还，偿还；把…放回原处Node n. 节点；瘤；[数] 叉点Element n. 元素；要素；原理；成分；自然环境parentNode 父节点childNodes 子节点nextSibling 下一个兄弟节点previous adj.以前的; 先前的; 过早的; （时间上） 稍前的;previousSibling 上一个兄弟节点previousElementSibling 上一个兄弟元素nextElementSibling 下一个兄弟元素firstChild 第一个子节点lastChild 最后一个子节点firstElementChild 第一个子元素lastElementChild 最后个子元素innerText 底层模板, 内部的纯文本, 元素文本append vt.附加; 添加; 贴上; 签（名）appendChild 方法, 添加节点方法removeChild 去除节点方法createElement 创建元素attribute n. 属性；特质setAttribute 设置属性getAttribute 获取属性removeAttribute 移除属性 熟悉部分 123456789101112area 地区; 区域，范围; 面积，平地; 领域;perimeter &lt;数&gt;周长; 周围，边界;meter “米, 公尺#计量器, 仪表; 计量官; 计量监督员”radius 半径（距离）; 用半径度量的圆形面积; 半径范围; 桡骨;difference 差别，差异; [数]差数，差额; 意见分歧; 特色;product 产品; 结果; 乘积; 作品;destination 目的，目标; 目的地，终点;Object n. 目标；物体；客体；宾语Model n. 模型；典型；模范；模特儿；样式instance n. 实例；情况；建议inner adj. 内部的；内心的；精神的transparent adj. 透明的；显然的；坦率的；易懂的 了解部分 123selected 挑选出来的checked 检查;选中的；current 现在的；流通的，通用的；最近的；草写的 常用数组方法 12345678sort vt. 将…分类；将…排序；挑选出某物shift 改变; 去掉; 摆脱掉; 换挡;unshift 松开打字机或键盘的字型变换键;方法将元素插入到一个数组的开始部分reverse 颠倒；倒转concat 合并多个数组；合并多个字符串slice 切成片; 切下; 划分;splice 拼接；接合；使结婚source n.根源，本源; 源头，水源; 原因; 提供消息的人; 英 [sɔːs] 美 [sɔrs] 常用的日期函数 123456789getTime 取得系统时间getMilliseconds 取得 Date 对象中的毫秒字段getSeconds 返回时间的秒getMinutes 返回时间的分钟数getHours 返回时间的小时字段getDay 返回一周的某一天数字getDate 返回月份的某一天getMonth 取得 Date 对象中表示月份的数字getFullYear 返回当前Date对象中的年份值 常用方法 123456789trim 会从一个字符串的两端删除空白字符split 用于把一个字符串分割成字符串数组forEach 为每一个遍历，循环map 地图，天体图; 类似地图的事物;indexOf 查找字符或者子串第一次出现的地方,lastIndexOf 查找字符或者子串是后一次出现的地方every 每个; 每; 所有可能的; 充足的;some 一些; 某个; 大约; 相当多的;ceil vt. 装天花板，装船内格子板; BOM 12window n. 窗口; 窗，窗户;setTimeout 法用于在指定的毫秒数后调 用函数或计算表达式 1234interval n. 间隔; 幕间休息; （数学） 区间;setInterval 设置时间间隔, 按照指定时间周期调用函数或计算表达式, 循环history n. 历史，历史学；历史记录；来历location n. 定位; 位置，场所; 外景（拍摄地）; 掌握部分 1234567891011path n. 小路，路; 路线，路程; 〈比喻〉（人生的）道路; （思想，行为，生活的） 途径;port n. 港口; （事情的） 意义; （计算机与其他设备的） 接口; （船、飞机等的） 左舷;protocol n. 礼仪; （外交条约的） 草案; （数据传递的） 协议; 科学实验报告（或计划）;navigator n. 领航员; 航海家，航行者，航海者; （船舶，飞机的） 驾驶员; 一个浏览器的品牌;agent n. 代理人; 代理商; 特工; 药剂; 英useragent 用户代理, 代理程式识别码back vt. 使后退; 支持; 加背书于; 下赌注于;vi. 后退; 倒退;offset vt. 抵消; 补偿; （为了比较的目的而）把…并列（或并置） ; 为（管道等）装支管;step n. 步，脚步; 步骤，手段; 步调; 级别;animate vt. 使有生气; 驱动; 使栩栩如生地动作; 赋予…以生命;Extensible adj. 可展开的，可扩张的，可延长的; js API 12345client n. 顾客; 当事人; 诉讼委托人; [计算机] 客户端;resize vt. 调整大小offsetHeight 网页内容实际高度math n. 数学getComputedStyle 可以获取当前元素所有最终 使用的 CSS 属性值 常用部分 1234567891011121314compute vt. 计算；估算；用计算机计算computed v. 计算，估算computer n. （电子） 计算机，电脑;floor n. 地板，地面；楼层；基底；议员席mode n. 模式；方式；风格；时尚 英compatMode 兼容模式；document.compatMode(判断当前浏览器采用的渲染方式)responsive adj.应答的，响应的; 反应灵敏的; 共鸣的; 易反应的;tablet 药片,小块 .碑，匾; 便笺簿,平板电脑wrap n. 膝毯，披肩，围巾，围脖，头巾，罩衫，外套，大衣; 包装纸;slide n. 滑动；幻灯片；滑梯；雪崩 英assign vt. 分配；指派；计 赋值 英[əinsert vt. 插入; 嵌入; （在文章中） 添加; 加before prep. 在…之前; 先于，优于; 当着…的面; 与其…;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎥-各个跨端技术原理归纳","slug":"🎥-各个跨端技术原理归纳","date":"2021-11-01T16:00:00.000Z","updated":"2022-06-10T01:04:40.176Z","comments":true,"path":"2021/undefined/01/🎥-各个跨端技术原理归纳/","link":"","permalink":"http://example.com/2021/undefined/01/%F0%9F%8E%A5-%E5%90%84%E4%B8%AA%E8%B7%A8%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%BD%92%E7%BA%B3/","excerpt":"","text":"原理归纳1.react-native brige js &#x3D;&gt; brige &#x3D;&gt; native2.flutter flutter &#x3D;&gt; skia &#x3D;&gt; 原生3. uni-app 小程序 ： 小程序 &#x3D;&gt; 编译器 &#x3D;&gt;原生 原生 : webview weex &#x3D;&gt; 原生4.taro 小程序 : 小程序 &#x3D;&gt; 编译器 &#x3D;&gt;原生 原生： Rn &#x3D;&gt; 原生各平台支持情况 平台 \\ 跨段方案 RN flutter uni-app Taro 微信小程序 ❌ ❌ ✅ ✅ web ❌ ✅ ✅ ✅ IOS ✅ ✅ ✅ ✅ android ✅ ✅ ✅ ✅ 深入理解Flutter的图形图像绘制原理——图形库skia剖析","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎅🔥-Python-+-JavaScript-=-🔥🔥🔥","slug":"🎅🔥-Python-+-JavaScript-=-🔥🔥🔥","date":"2021-10-25T16:00:00.000Z","updated":"2022-06-10T01:04:40.175Z","comments":true,"path":"2021/undefined/25/🎅🔥-Python-+-JavaScript-=-🔥🔥🔥/","link":"","permalink":"http://example.com/2021/undefined/25/%F0%9F%8E%85%F0%9F%94%A5-Python-+-JavaScript-=-%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5/","excerpt":"","text":"当涉及到 web开发时，javascript是无人能及的存在，但是有的时候我们需高要求的工作，比如解析一大堆数据，这样pyhton就是个更好的选择，但这仅仅是我们网站的一个功能而已，仅因为这个我们就需要转到python吗，也许不用。 如果我们可以大部分使用 Node JS, 在必要情况下使用python呢？碉堡了, 对吧，如有需要，我们可以使用child process 去运行一个python脚本 123456const spawn = require(&#x27;child_process&#x27;).spawnapp.get(&quot;process_data&quot;, (req, res) =&gt; &#123; spawn(&#x27;python3&#x27;, [&#x27;script.py&#x27;])&#125;) 12# script.pydoSometing() 我们也可以传参 1234567const spawn = require(&#x27;child_process&#x27;).spawnapp.get(&quot;process_data&quot;, (req, res) =&gt; &#123; const msg = &quot;Hello&quot; spawn(&#x27;python3&#x27;, [&#x27;script.py&#x27;, msg])&#125;) 在 python中我们必须通过 import the sys 才能接收数据 12345678910import sys, jsondef main(): msg = sys.argv[1] doSometing(msg)if __name__ == &#x27;__main__&#x27;: main() 我们也可以通过stream代替 生成python进程传参 12345678910const spawn = require(&#x27;child_process&#x27;).spawn,const py = spawn(&#x27;python3&#x27;, [&#x27;script.py&#x27;])const data = &#123; msg: &quot;Hello&quot;&#125;py.stdin.write(JSON.stringify(data)) //we have to send data as a string, so we are using JSON.stringifypy.stdin.end() 123456789import sys, jsondef main(): lines = sys.stdin.readlines() data = json.loads(lines) doSometing(data[&#x27;msg&#x27;])if __name__ == &#x27;__main__&#x27;: main() 最后通过python 回调函数把数据传到node 1234567const spawn = require(&#x27;child_process&#x27;).spawnconst py = spawn(&#x27;python3&#x27;, [&#x27;cscript.py&#x27;])py.stdout.on(&#x27;data&#x27;, function(res)&#123; let data = JSON.parse(res.toString()) console.log(data)&#125;) 1234567import sys# You will have your own implementation of get data. In this case lets assume it returns a dict/jsonres = getData()print(json.dumps(data))sys.stdout.flush() 翻译自 https://dev.to/0shuvo0/python-javascript--1nd6","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦qs简单使用","slug":"🌦🌦qs简单使用","date":"2021-10-22T16:00:00.000Z","updated":"2022-06-10T01:04:40.175Z","comments":true,"path":"2021/undefined/22/🌦🌦qs简单使用/","link":"","permalink":"http://example.com/2021/undefined/22/%F0%9F%8C%A6%F0%9F%8C%A6qs%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"qs使用 A querystring parsing and stringifying library with some added security. 1.qs.parse()将URL解析成对象的形式123456const Qs = require(&#x27;qs&#x27;);let url = &#x27;method=query_sql_dataset_data&amp;projectId=85&amp;appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0&#x27;;Qs.parse(url);console.log(Qs.parse(url)); 12345&#123; method: &quot;query_sql_dataset_data&quot;, projectId: 85, appToken: &quot;7d22e38e-5717-11e7-907b-a6006ad3dba0&#125; 2. qs.stringify()将对象 序列化成URL的形式，以&amp;进行拼接1234567891011const Qs = require(&#x27;qs&#x27;);let obj= &#123; method: &quot;query_sql_dataset_data&quot;, projectId: &quot;85&quot;, appToken: &quot;7d22e38e-5717-11e7-907b-a6006ad3dba0&quot;, datasetId: &quot; 12564701&quot; &#125;;Qs.stringify(obj);console.log(Qs.stringify(obj)); 123method=query_sql_dataset_data&amp;projectId=85&amp;appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0&amp;datasetId=%2012564701 usage http请求处理当post 请求报文格式为application&#x2F;x-www-form-urlencoded POST http://www.example.com HTTP&#x2F;1.1Content-Type: application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8title&#x3D;test&amp;sub%5B%5D&#x3D;1&amp;sub%5B%5D&#x3D;2&amp;sub%5B%5D&#x3D;3 需要对参数进行转化，固定格式 key=value&amp;key1=value1 在axios中应用,对参数进行处理 123456789101112let params = &#123; password: 123456, name: star&#125;this.$axios.post(&#123; url:&quot;/admin/login&quot;, params: qs.stringfy(params)&#125;).then(res =&gt; console.log(res))// password=123456&amp;name=star 参考: https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/ https://www.jianshu.com/p/62546d82f380https://imququ.com/post/four-ways-to-post-data-in-http.htmlhttps://blog.csdn.net/qq_43290288&#x2F;article&#x2F;details&#x2F;106683304","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦜🦜-vue-router-同一个页面地址栏参数改变，页面不刷新的问题","slug":"🦜🦜-vue-router-同一个页面地址栏参数改变，页面不刷新的问题","date":"2021-10-21T16:00:00.000Z","updated":"2022-06-10T01:04:40.174Z","comments":true,"path":"2021/undefined/21/🦜🦜-vue-router-同一个页面地址栏参数改变，页面不刷新的问题/","link":"","permalink":"http://example.com/2021/undefined/21/%F0%9F%A6%9C%F0%9F%A6%9C-vue-router-%E5%90%8C%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%8F%82%E6%95%B0%E6%94%B9%E5%8F%98%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"vue-router 同一个页面地址栏参数改变（比如文章的发布和编辑是同一个页面），不会触发vue的created或者mounted钩子，所以数据不会重新渲染。 解决办法有两种： 1：监听地址栏变化（watch）,这是vue-router官方给出的解决办法。监听路由变化，把初始化的方法重新写到监听的方法里面执行 123456789101112131415watch: &#123; &#x27;$route&#x27; (to, from) &#123; this.getData(this.$route.query.id) &#125;&#125; methods: &#123; async getData (id) &#123; // 按照id获取数据 const &#123; data: &#123; result &#125; &#125; = await this.$http.get(&#x27;getShowList&#x27;, &#123; params: &#123; id &#125; &#125;) this.dataList = result &#125;&#125; 2、给router-view加个唯一的key，来保证路由切换时都会重新渲染触发钩子了 123456789101112131415161718&lt;template&gt; &lt;div id=&quot;main&quot; class=&quot;app-main&quot;&gt; &lt;transition :name=&quot;transitionName&quot;&gt; &lt;router-view class=&quot;router-box&quot; :key=&quot;key&quot;&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed:&#123; key() &#123; return this.$route.name?this.$route.name+ +new Date():this.$route+ +new Date() &#125; &#125; &#125;;&lt;/script&gt; 第二种方法，页面每次切换都会跑到顶部，需要配合 scroll处理","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-import---as-怎么用","slug":"🌦🌦-import---as-怎么用","date":"2021-10-21T16:00:00.000Z","updated":"2022-06-10T01:04:40.174Z","comments":true,"path":"2021/undefined/21/🌦🌦-import---as-怎么用/","link":"","permalink":"http://example.com/2021/undefined/21/%F0%9F%8C%A6%F0%9F%8C%A6-import---as-%E6%80%8E%E4%B9%88%E7%94%A8/","excerpt":"","text":"lib.js 1234export var config = _config;export var db = _db;export var storage = _storage; main.js在 main.js中使用 lib.js 1import &#123;storage,db,config&#125; from &quot;./lib&quot; 也可以写成 12import * as lib from &quot;./lib&quot;lib.db()","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-为什么-export-default-var-a-=-1-在ES6中不被允许-","slug":"🌦🌦-为什么-export-default-var-a-=-1-在ES6中不被允许-","date":"2021-10-18T16:00:00.000Z","updated":"2022-06-10T01:04:40.174Z","comments":true,"path":"2021/undefined/18/🌦🌦-为什么-export-default-var-a-=-1-在ES6中不被允许-/","link":"","permalink":"http://example.com/2021/undefined/18/%F0%9F%8C%A6%F0%9F%8C%A6-%E4%B8%BA%E4%BB%80%E4%B9%88-export-default-var-a-=-1-%E5%9C%A8ES6%E4%B8%AD%E4%B8%8D%E8%A2%AB%E5%85%81%E8%AE%B8-/","excerpt":"","text":"babel输入以下代码，异常显示 Only expressions, functions or classes are allowed as the default export.export default 只能导处函数 表达式 和 class export default function() &#123;&#125;export defaut &#123;&#125;let foo = () =&gt; &#123;&#125;; export default foo 为什么不能这样导出呢，避免出现下面的情况,多个参数导致的混乱export default var a, b, c; // Non-sensical","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"☁️☁️-node-常用工具包","slug":"☁️☁️-node-常用工具包","date":"2021-10-17T16:00:00.000Z","updated":"2022-06-10T01:04:40.173Z","comments":true,"path":"2021/undefined/17/☁️☁️-node-常用工具包/","link":"","permalink":"http://example.com/2021/undefined/17/%E2%98%81%EF%B8%8F%E2%98%81%EF%B8%8F-node-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85/","excerpt":"","text":"node 版本管理工具 –n安装:npm install -g n 使用列出可选择的 版本:$ n 安装某个 版本:$ n &lt;version&gt; npm 代理管理工具 – nrm安装:npm install -g nrm 使用列出可选择的源:$ nrm ls 12345678910 npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/* taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 切换使用的$ nrm use npm 1Registry has been set to: https://registry.npmjs.org/","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"-📁📁-linux-文件常用命令","slug":"-📁📁-linux-文件常用命令","date":"2021-10-15T16:00:00.000Z","updated":"2022-06-10T01:04:40.173Z","comments":true,"path":"2021/undefined/15/-📁📁-linux-文件常用命令/","link":"","permalink":"http://example.com/2021/undefined/15/-%F0%9F%93%81%F0%9F%93%81-linux-%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"文件夹重命名 mv，mv相当于剪切操作mv命令既可以重命名，又可以移动文件或文件夹。例子：将目录name重命名为namingmv /path/filename /targetPath/filename 复制copy /path/filename /targetPath/filename 创建文件夹 groupmkdir group 删除文件夹删除文件夹 grouprm -rf group 删除文件夹所有文件和文件夹rm -rf * 上传本地文件到服务器scp /path/filename username@servername:/path","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦜🦜-vue中使provide中的数据变为响应式","slug":"🦜🦜-vue中使provide中的数据变为响应式","date":"2021-10-12T16:00:00.000Z","updated":"2022-06-10T01:04:40.172Z","comments":true,"path":"2021/undefined/12/🦜🦜-vue中使provide中的数据变为响应式/","link":"","permalink":"http://example.com/2021/undefined/12/%F0%9F%A6%9C%F0%9F%A6%9C-vue%E4%B8%AD%E4%BD%BFprovide%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E4%B8%BA%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"","text":"正常使用provide的方式：1234// 父组件中：provide:&#123; for: &#x27;demo&#x27;&#125; 这样子组件中无论多深的子组件都可以使用： 1234567// 子组件inject:[&#x27;for&#x27;],data()&#123; return&#123; demo: this.for &#125;&#125; 但是上面的写法有一定的问题，比如父组件中for变量的值如果我们是在mounted方法中请求后台数据再更改provide中for的值，那么在子组件中获取不到更改后的for的值。 这时候就需要换一种写法：12345678910111213141516// 父组件中：data () &#123; return &#123; for: &#123;&#125; &#125;&#125;,provide() &#123; return &#123; provObj: this.for &#125;; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.for.fp= &#x27;demo&#x27;; &#125;, 2000);&#125; 1234567// 子组件中：inject:[&#x27;provObj&#x27;],data()&#123; return&#123; demo: this.provObj.fp &#125;&#125; provide源码使用defineReactive, 让provide变为响应式的, 所以根元素属性 this.for 无效，必须监听下一级属性 this.for.fp 1234567891011export function initInjections (vm: Component) &#123;const result = resolveInject(vm.$options.inject, vm)if (result) &#123; observerState.shouldConvert = false Object.keys(result).forEach(key =&gt; &#123; `defineReactive(vm, key, result[key])` // defineReactive &#125;) observerState.shouldConvert = true &#125;&#125; inject源码 12345678910111213141516171819202122232425262728293031323334353637export function resolveInject (inject: any, vm: Component): ?Object &#123; if (inject) &#123; // inject 是 :any 类型因为流没有智能到能够指出缓存 const result = Object.create(null) // 获取 inject 选项的 key 数组 const keys = hasSymbol ? Reflect.ownKeys(inject).filter(key =&gt; &#123; /* istanbul ignore next */ return Object.getOwnPropertyDescriptor(inject, key).enumerable &#125;) : Object.keys(inject) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const provideKey = inject[key].from let source = vm while (source) &#123; if (source._provided &amp;&amp; provideKey in source._provided) &#123; result[key] = source._provided[provideKey] break &#125; source = source.$parent &#125; if (!source) &#123; if (&#x27;default&#x27; in inject[key]) &#123; const provideDefault = inject[key].default result[key] = typeof provideDefault === &#x27;function&#x27; ? provideDefault.call(vm) : provideDefault &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(`Injection &quot;$&#123;key&#125;&quot; not found`, vm) &#125; &#125; &#125; return result &#125;&#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-indexOf，includes，空字符串，返回的什么","slug":"🌦🌦-indexOf，includes，空字符串，返回的什么","date":"2021-10-09T16:00:00.000Z","updated":"2022-06-10T01:04:40.172Z","comments":true,"path":"2021/undefined/09/🌦🌦-indexOf，includes，空字符串，返回的什么/","link":"","permalink":"http://example.com/2021/undefined/09/%F0%9F%8C%A6%F0%9F%8C%A6-indexOf%EF%BC%8Cincludes%EF%BC%8C%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BB%80%E4%B9%88/","excerpt":"","text":"最近刷letcode碰到的小问题 indexOf12let str = &quot;string&quot;str.indexOf(&quot;&quot;) // 0 mdn解释The index of the first occurrence of searchValue, or -1 if not found. An empty string searchValue produces strange results. With no fromIndex value, or any fromIndex value lower than the string’s length, the returned value is the same as the fromIndex value: 1234&#x27;hello world&#x27;.indexOf(&#x27;&#x27;) // returns 0&#x27;hello world&#x27;.indexOf(&#x27;&#x27;, 0) // returns 0&#x27;hello world&#x27;.indexOf(&#x27;&#x27;, 3) // returns 3&#x27;hello world&#x27;.indexOf(&#x27;&#x27;, 8) // returns 8 如果是空的，返回传入的序列，再往下需要查看js编译器源码了 includes传入空字符串，返回true 12let str = &quot;string&quot;str.includes(&quot;&quot;) // true includes，polyfill，目测includes也是通过indexOf实现的 12345678910if (!String.prototype.includes) &#123; String.prototype.includes = function(search, start) &#123; &#x27;use strict&#x27;; if (search instanceof RegExp) &#123; throw TypeError(&#x27;first argument must not be a RegExp&#x27;); &#125; if (start === undefined) &#123; start = 0; &#125; return this.indexOf(search, start) !== -1; &#125;;&#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦜🦜vue-$emit-同步调用","slug":"🦜🦜vue-$emit-同步调用","date":"2021-10-07T16:00:00.000Z","updated":"2022-06-10T01:04:40.171Z","comments":true,"path":"2021/undefined/07/🦜🦜vue-$emit-同步调用/","link":"","permalink":"http://example.com/2021/undefined/07/%F0%9F%A6%9C%F0%9F%A6%9Cvue-$emit-%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8/","excerpt":"","text":"标题换一种说法：vue $emit 调用父组件异步方法，执行完毕后再执行子组件的某方法使用回调的形式 123456789101112// 组件的html中添加事件 @getData=&quot;getData&quot;methods : &#123; getData(params, callback) &#123; console.log(&quot;子组件的传递到父组件的参数&quot;, params); console.log(&quot;模拟发送后台异步请求，延迟3s...&quot;); setTimeout(() =&gt; &#123; console.log(&quot;异步请求结束，执行回调函数&quot;); callback(&quot;父组件传到子组件的文本666&quot;) &#125;, 3000) &#125;&#125; 子组件 1234567// 通过 $emit 触发父组件的方法// 参数：触发的事件名称、事件参数，事件参数// 把方法当做事件参数传递到父组件，由父组件调用执行。this.$emit(&#x27;getData&#x27;, 10, (res)=&gt; &#123; console.log(&quot;父组件的返回结果：&quot;, res); //由父组件调用&#125;)","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-js-修改对象key","slug":"🌦🌦-js-修改对象key","date":"2021-09-29T16:00:00.000Z","updated":"2022-06-10T01:04:40.171Z","comments":true,"path":"2021/undefined/29/🌦🌦-js-修改对象key/","link":"","permalink":"http://example.com/2021/undefined/29/%F0%9F%8C%A6%F0%9F%8C%A6-js-%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1key/","excerpt":"","text":"原始数据: 123456let Obj=&#123; parentid:&quot;43323wsd2e2d2e33r3redad&quot;, head_img:&quot;i am a url&quot;,&#125; 想要的数据： 123456let newObj=&#123; ParentID:&quot;43323wsd2e2d2e33r3redad&quot;, avator:&quot;i am a url&quot;,&#125; 第一种，正则替换，缺点，如果value等于key,会有问题123456789101112/*** @param &#123;Object&#125; &#123; parentid:&quot;43323wsd2e2d2e33r3redad&quot;&#125;* @param &#123;Object&#125; &#123; parentid: &quot;ParentID&quot;&#125;* @return &#123;Object&#125; &#123; ParentID:&quot;43323wsd2e2d2e33r3redad&quot;&#125;*/const renameKeys = (target, keys) =&gt; &#123; const key = Object.keys(keys).reduce((pre, cur) =&gt; pre + &quot;|&quot; + cur) const reg = new RegExp(`$&#123;key&#125;`, &quot;ig&quot;) return JSON.parse(JSON.stringify(target).replace(reg, matched =&gt; keys[matched]))&#125; 第二种，reduce产生新的对象，缺点，使用更大内存123456789101112const renameKeys = (obj,keysMap) =&gt; Object.keys(obj).reduce( (acc, key) =&gt; (&#123; ...acc, ...&#123; [keysMap[key] || key]: obj[key] &#125; &#125;), &#123;&#125; );const obj = &#123; parentid:&quot;43323wsd2e2d2e33r3redad&quot;&#125;;renameKeys(obj, &#123; parentid: &quot;ParentID&quot;&#125;) // &#123; ParentID:&quot;43323wsd2e2d2e33r3redad&quot;&#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-cookie-为什么作为token-放在header里","slug":"🌦🌦-cookie-为什么作为token-放在header里","date":"2021-09-21T16:00:00.000Z","updated":"2022-06-10T01:04:40.171Z","comments":true,"path":"2021/undefined/21/🌦🌦-cookie-为什么作为token-放在header里/","link":"","permalink":"http://example.com/2021/undefined/21/%F0%9F%8C%A6%F0%9F%8C%A6-cookie-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAtoken-%E6%94%BE%E5%9C%A8header%E9%87%8C/","excerpt":"","text":"现象：后端配置了cores跨域，前端直接请求，没有通过代理，这样如果设置cookie，只能设置到， localhost里，request header 无法带过去 手动设置header Access-Token 123header: &#123; Access-Token: Cookies.get(&quot;Access-Token&quot;)&#125; 通过代理，携带在在request header中的cookie,cookie自动带入，无须设置 原因：1.cores技术成熟，后端配置方便 2.前端开发涉及的范围越来越广，小程序、hybrid、electron这些都不是纯粹的web 开发，后端既要处理原生的http请求又要处理web的http请求原生不是browser这意味着原生请求没有cookie，那么如果web和原生共用同一个api，这就意味着后端需要两套解析token的机制，何不直接就全放在header里面用同一套逻辑处理呢。 3.主要还是cookie会被浏览器自动带上, 劫持了才容易攻击.","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎨🎨-git-一些常用参数设置","slug":"🎨🎨-git-一些常用参数设置","date":"2021-09-18T16:00:00.000Z","updated":"2022-06-10T01:04:40.170Z","comments":true,"path":"2021/undefined/18/🎨🎨-git-一些常用参数设置/","link":"","permalink":"http://example.com/2021/undefined/18/%F0%9F%8E%A8%F0%9F%8E%A8-git-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"-u123[-u | --set-upstream]git push -u origin main git push ---set-upstream origin main 设置默认推送分支 origin1git remote add origin http:xxxxx origin 是提交远程的命名 也可以自己命名比如 ppp o –help比如git push 1git push --help git 全局配置修改第一种 vi 1vi ~/.gitconfig 第二种 1git config --global --edit","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🗳🗳-nginx-启动停止命令","slug":"🗳🗳-nginx-启动停止命令","date":"2021-09-14T16:00:00.000Z","updated":"2022-06-10T01:04:40.170Z","comments":true,"path":"2021/undefined/14/🗳🗳-nginx-启动停止命令/","link":"","permalink":"http://example.com/2021/undefined/14/%F0%9F%97%B3%F0%9F%97%B3-nginx-%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动$ ./nginx 重启nginx $ ./nginx -s reload 查找nginx 位置$ whereis nginx 检测 nginx.config正确性1nginx -t","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"☀️☀️-编程范式----shell-子文件异步模式-VS--JS-async-await","slug":"☀️☀️-编程范式----shell-子文件异步模式-VS--JS-async-await","date":"2021-09-12T16:00:00.000Z","updated":"2022-06-10T01:04:40.243Z","comments":true,"path":"2021/undefined/12/☀️☀️-编程范式----shell-子文件异步模式-VS--JS-async-await/","link":"","permalink":"http://example.com/2021/undefined/12/%E2%98%80%EF%B8%8F%E2%98%80%EF%B8%8F-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F----shell-%E5%AD%90%E6%96%87%E4%BB%B6%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F-VS--JS-async-await/","excerpt":"","text":"问题：在 shell 下有 A、B、C、D 四个命令,需要先执行 A再执行 B、C最后执行 D 其中, B、C 耗时较多， 但是，互不干扰，可以同步执针对以上情形，bash提供了一个内置的命令来帮助管理异步执行。wait命令可以让父脚本暂停，直到指定的进程（比如子脚本）结束。 shell子进程 和 wait123456./A./B &amp; # 设为子进程./C &amp;pid=$1wait (pid)./D javascript asyncjs 中的 async await 设计类似shell 中的这种异步模式，区别是 await 需要new Promise 包裹起来 123456async AllProcess = () =&gt; &#123; A(); await B(); await C(); D();&#125; 在shell中本身是文件包裹，相当于一个Promise了","categories":[],"tags":[{"name":"编程范式","slug":"编程范式","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"}]},{"title":"☁️☁️-npm-bin-全局命令原理","slug":"☁️☁️-npm-bin-全局命令原理","date":"2021-09-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.170Z","comments":true,"path":"2021/undefined/10/☁️☁️-npm-bin-全局命令原理/","link":"","permalink":"http://example.com/2021/undefined/10/%E2%98%81%EF%B8%8F%E2%98%81%EF%B8%8F-npm-bin-%E5%85%A8%E5%B1%80%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86/","excerpt":"","text":"前言用过构建工具的亲们知道，通常通过全局安装一个 xxx-cli 的 npm 包，就能在命令行用命令进行构建。那么这个 npm 包如何变成一个可执行的命令呢？ npm cli 开发步骤1. 使用 npm init 初始化一个项目目录 my-cli。2. 在 package.json 中添加或者编辑 bin 字段：12345678&#123; &quot;name&quot;: &quot;my-cli&quot;, ..., &quot;bin&quot;: &#123; &quot;command-name&quot;: &quot;jsfile&quot; // path of jsfile relative to package.json &#125;, ...&#125; commandName 就是命令的名字，jsfile 就是当用户键入命令时的处理程序。 3.代码开发。必须在 jsfile 文件的第一行写这行命令 #!&#x2F;usr&#x2F;bin&#x2F;env node，譬如：123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env nodeconst program = require(&#x27;commander&#x27;);const packageJson = require(&#x27;../package&#x27;);let defaultJsProcessors = [ &#x27;react&#x27; ];let defaultStyleProcessors = [ &#x27;sasslike&#x27; ];let defaultWebpackVersion = &#x27;4&#x27;;function parseListArgv( val ) &#123; if ( val ) &#123; return val.split( &#x27;,&#x27; ); &#125; else &#123; return []; &#125;&#125;program .version( packageJson.version, &#x27;-v, --version&#x27; ) .option( &#x27;-u, --use-version &lt;version-number&gt;&#x27;, &#x27;Webpack version&#x27; ) .option( &#x27;-j, --js-processors &lt;processors&gt;&#x27;, &#x27;Specify javascript processors&#x27;, parseListArgv ) .option( &#x27;-s, --style-processors &lt;processors&gt;&#x27;, &#x27;Specify style(css,image,fonts) processors&#x27;, parseListArgv ) .option( &#x27;--no-install&#x27;, &#x27;Do not install devDependncies package&#x27; ) .parse( process.argv );let jsProcessors = program.jsProcessors || defaultJsProcessors;let styleProcessors = program.styleProcessors || defaultStyleProcessors;let webpackVersion = program.useVersion || defaultWebpackVersion;if ( webpackVersion==&#x27;4&#x27; ) &#123; // code&#125; else &#123; // code&#125; npm cli 运行原理Unix-like 平台1.当全局安装 npm 包的时候，npm 会把 package.json 中 bin 配置的 command-name 添加到系统 $PATH中去。 拿 macOS 举例，npm 会在 &#x2F;usr&#x2F;local&#x2F;bin 下创建一个以 command-name 为名字的软链接，指向全局安装下来的&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;my-cli 包下面的 js：jsfile。（&#x2F;usr&#x2F;local&#x2F;bin 是在 $PATH 中的） 如果全局安装rollup： &#x2F;usr&#x2F;local&#x2F;bin 目录 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules 目录 2.在命令行键入 command-name 相当于执行了文本文件 jsfile。3.在执行的时候碰到第一行 #!&#x2F;usr&#x2F;bin&#x2F;env node，这是一个 shebang 行。这行告诉系统使用 node 去执行当前文件。（shebang 只有在Unix-like平台才有）4.执行 js 文件。这里有一个问题：#! 并不是一个符合 js 语法的语句，理论上直接执行是会有 syntax error 的。但是 node 对 shebang 行做了例外处理，所以用 node 执行带 shebang 行的 js 文件是没有问题的。 Windows 平台1.全局安装会把包安装到 C:\\Users\\username\\AppData\\Roaming\\npm\\node_modules下面，然后在 C:\\Users\\username\\AppData\\Roaming\\npm 生成一个以 command-name 为名字的 cmd 文件：command-name.cmd。（C:\\Users\\username\\AppData\\Roaming\\npm 在安装 npm 时被加入到 %PATH% 中） 2.在 Windows 平台运行 cmd 文件是不需要后缀名的，所以当在命令行键入 command-name 相当于执行 C:\\Users\\username\\AppData\\Roaming\\npm\\command-name.cmd。 3.为什么有这个 cmd 文件，因为 windows 平台没有 shebang，那么 command-name.cmd 就模拟了 #!&#x2F;usr&#x2F;bin&#x2F;env node 的功能，调用 C:\\Users\\username\\AppData\\Roaming\\npm\\node_modules\\my-cli\\ jsfile","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📣📣编程艺术和编程的本质","slug":"📣📣编程艺术和编程的本质","date":"2021-09-07T16:00:00.000Z","updated":"2022-06-10T01:04:40.169Z","comments":true,"path":"2021/undefined/07/📣📣编程艺术和编程的本质/","link":"","permalink":"http://example.com/2021/undefined/07/%F0%9F%93%A3%F0%9F%93%A3%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E5%92%8C%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"编程艺术最近看老外写的代码，感觉他们写代码就跟搞艺术一样，就像珍珠一样晶莹剔透，甚至注释比代码都多。 国外在产品中注入艺术气息的不再少数 法国大餐，秀色可餐。日本料理，精致温婉。苹果产品，兼顾艺术品味，简约大气又耐用。美国隐身战斗机，外观霸气，操作简约。欧洲、日本的汽车流线、颜色都很美，功能人性化。古罗马帝国作为横跨欧洲、非洲与亚洲的强大帝国，格外强调其建筑的威严，以给人不可侵犯的感觉。 当制造业开始讲求审美训练，艺术带给它什么硬核好处？学习艺术不但可以把工业产品做得更人性化，还可以把一个行业带到新的高度，国外好的工业产品在视觉上都会给人很大的冲突感，是美学的一部分。很多行业粗制滥造，只追求做出来，不会精益求精，产品也不会赏心悦目，没有体验感 「知乎」上有段评论：老美的代码看起来是一件艺术品，他们会在代码文件头、函数头里写上很漂亮工整的注释，然后项目有一个庞大复杂的架构，各种设计模式、框架结合使用，好像这些东西用得越多越流逼一样。 俄毛子的代码那简直就是天书，一股浓烈的geek气味伴随着灌满伏特加后眩晕的混沌感扑面而来。变量名写长一点清晰一点会死吗？plmm不是漂亮美眉，看了半天代码连猜带懵才知道是Platform Link Maintainess Manager。 印度人写的代码就像一条工业流水线出来的产品一样，每个都很规矩，但也很死板。一个环形消息缓存的东西用竟然数组来实现，然后在下标计算时倒来倒去。尼玛用个链表来实现会死是不。 中国人写的代码还是比较实用的，但如果不加控制就会犯低级错误。你见过为了查找一个用户id，先用select *从数据库把所有内容都捞出来，然后用个大大的for循环来查找的代码吗？我看了当时就泪奔无语了。 崇洋媚外不可取，夏之虫和井之蛙也不能做。希望我们能突破自己的认知，站在巨人的肩旁上，让自己不断强大。 编程的本质是什么？ 《教父》里说过：花半分钟就看透事物本质的人，和花一辈子都看不清本质的人，自然是不一样的人生。 所以我们尝试思考下编程的本质，或许可以让我们走的更远。 对于编程这件事，编写程序，就字面意思来讲，事情的结果是程序。 程序是啥意思呢? 广义上的程序是指，一系列的动作以相同的方式执行，在相同的环境下，总能得出相同的结果。 你比如开银行卡账户，你需要准备好材料，像身份证，去银行填表，核身，签字，最后拿到一张属于你的银行卡。 换一个人也要走同样的程序，同样要备好材料，填表，核身，签字，同样要到银行办理，同样最后拿到了银行卡。 你会发现，定义里面有三个相同，也就是程序最大的特点就是重复。 只不过上边例子里的重复，是在银行这个地方发生的。每天做着相同程序的业务，只是不同的客户，不同的柜员。 但开卡业务只能在银行办理，这就很受局限了。我得花费时间和体力，跑到银行，还得挑银行上班的时间。那有没有办法，我不去银行也能把银行卡开下来呢。计算机和互联网的出现，就解决了这个问题。 要交的材料，要走的程序，要拿的卡，都不变，只是整个操作环境，从线下的银行，变成了线上的某个载体，可以是个 PC 端 Web 网站，也可以是个移动端 APP。 线上就是指互联网，它能够让信息的传递跨越空间，而操作的载体，无论是 Web 网站 还是 APP，背后都是计算机程序。 从前你要花一个小时坐公交去银行，如今足不出户点点手机就能办理业务。 计算机上的这些程序从哪来的？ 就是程序员编写的。 所以程序员要做的事就是，把线下现实世界的事情，编到线上计算机里来做。 这有点像电影编剧的角色，都要取材于现实。 不同的是，电影编剧会充分虚构，保证艺术源于生活又高于生活，产出物是一两个小时的影像。 而程序员要充分还原现实，保证程序符合正常逻辑不会错乱，产出物是电子设备上的应用程序。 那编程的目的就很清晰了，用计算机来解决现实世界的问题。 无论是现实世界还是计算机，我们做一件事，都需要有三个核心要素：输入（Input）、处理（Process）和输出（Output），简称 IPO。 编程就是把现实世界的问题，映射到计算机的 IPO 中。 那怎么把现实世界的问题映射到计算机的 IPO 中呢？ 我理解要通过模型。 什么是模型？ 模型是指用一个较为简单的东西来代表另一个东西。 如果要简单化一个东西，那就需要对这个东西进行分析，然后抽象。 抽象的维度，决定着最后软件的形式。 比如 form-render抽象层次，可以是拖拽式，可以config 配置， 可以是表格配置 如果对计算机本身进行抽象，那软件就会以机器代码或汇编语言的形式呈现。 如果对计算处理逻辑进行抽象，那软件就会以非结构化的高级语言呈现，比如 Basic。 如果对问题领域过程进行抽象，那软件就会以结构化的高级语言呈现，比如 C。 如果对问题领域元素进行抽象，那软件就会以面向对象程序设计语言呈现，比如 Java。 也就是说，编程语言是现实世界到计算机世界抽象的机制。 总结: 枚举 &#x3D;&gt; 归纳 &#x3D;&gt; 抽象 编程的本质就是可计算,可计算的基础就是建模建模可实现必须简化,简化的方式就是抽象简化的前提就是限定范围。然后一切编程成为了限定范围内抽象模型的数学计算的计算机表达 所谓的编程，就是使用某种语言，在某个维度，把现实世界抽象成简单的模型，然后设计和实现出可运行的计算机软件，也就是完整的 IPO。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"☀️☀️最近使用设计模式总结","slug":"☀️☀️最近使用设计模式总结","date":"2021-09-06T16:00:00.000Z","updated":"2022-06-10T01:04:40.242Z","comments":true,"path":"2021/undefined/06/☀️☀️最近使用设计模式总结/","link":"","permalink":"http://example.com/2021/undefined/06/%E2%98%80%EF%B8%8F%E2%98%80%EF%B8%8F%E6%9C%80%E8%BF%91%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.订阅发布模式众所周知，react中没有bus这个概念，如果遇到react中使用bus的情况，怎么办呢首先 , 什么是bus, event Bus is only a Global Function Register; 123456789101112131415161718192021222324252627282930313233343536let Bus = function () &#123; this.cache = [];&#125;;// registerBus.prototype.$on = function (handleEvent, fn) &#123; for (let i = 0; i &lt; this.cache.length; i++) &#123; let [first] = Object.keys(this.cache[i]); if (first === handleEvent) &#123; return; &#125; &#125; this.cache.push(&#123; [handleEvent]: fn &#125;);&#125;;// triggerBus.prototype.$emit = function (handleEvent) &#123; const [first, ...rest] = Array.from(arguments); for (let i = 0; i &lt; this.cache.length; i++) &#123; if (this.cache[i][handleEvent]) &#123; this.cache[i][handleEvent](...rest); &#125; &#125;&#125;;// cancel registerBus.prototype.$off = function (handleEvent) &#123; for (let i = 0; i &lt; this.cache.length; i++) &#123; let [first] = Object.keys(this.cache[i]); if (first === handleEvent) &#123; this.cache.splice(i, 1); i = i - 1; &#125; &#125;&#125;; Example：1234567let bus = new Bus();bus.$on(&quot;send&quot;,()=&gt;&#123; console.log(&quot;onSend&quot;)&#125;)bus.$emit(&quot;send&quot;) // onSend 2.装饰器模式js 本身没有装饰器 @语法糖，我们可以借助babel插件 123npm i @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties -S 然后配置 babal-loader 123456789101112131415161718192021222324252627&#123; test: /\\.(tsx?|jsx)$/, exclude: /node_modules/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; sourceMaps: true, presets: [ [&quot;@babel/preset-typescript&quot;, &#123; isTSX: true, allExtensions: true&#125;] ], plugins: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ], [ &quot;@babel/plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot;: true &#125; ] ] &#125; &#125; &#125;; cool，我们接下来可以愉快的使用装饰者了， Example:在软件开发中，我们经常碰到，连续点击导致问题的情况,此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果.已 debounce为例：App.jsx 123456789101112131415161718192021import debounce from &quot;./debounce&quot;class App extends React.Component &#123; constructor(props) &#123; super(props); &#125; @debounce(500, false) handleOk() &#123; this.post(&#x27;xxx&#x27;) &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;handleOk.bind(this)&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; debounce.js 1234567891011121314151617181920212223242526272829303132function _debounce(func, wait) &#123; let timeout; return function () &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; else &#123; timeout = setTimeout(() =&gt; &#123; func.apply(this); &#125;, wait); &#125; &#125;;&#125;const debounce = wait =&gt; &#123; return function handleDescriptor(target, key, descriptor) &#123; const callback = descriptor.value; if (typeof callback !== &quot;function&quot;) &#123; throw new SyntaxError(&quot;Only functions can be debounced&quot;); &#125; const fn = _debounce(callback, wait); return &#123; ...descriptor, value() &#123; fn.apply(this); &#125; &#125;; &#125;;&#125;;export default debounce; 3.代理模式代理模式符合设计模式中单一原则，是非常常见的设计模式，react HOC本身就是代理模式的变种 Easy Example:123456789101112131415161718192021222324252627282930313233343536373839/**************** 计算乘积 *****************/var mult = function()&#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i++ )&#123; a = a * arguments[i]; &#125; return a;&#125;;/**************** 计算加和 *****************/var plus = function()&#123; var a = 0; for ( var i = 0, l = arguments.length; i &lt; l; i++ )&#123; a = a + arguments[i]; &#125; return a;&#125;;/**************** 创建缓存代理的工厂 *****************/var createProxyFactory = function( fn )&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call( arguments, &#x27;, &#x27; ); if ( args in cache )&#123; return cache[ args ]; &#125; return cache[ args ] = fn.apply( this, arguments ); &#125;&#125;;var proxyMult = createProxyFactory( mult ),proxyPlus = createProxyFactory( plus );alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10 React HOC Example:在一个软件中，有许多表格类，网页，每个网页都有搜索栏，表格页码，联动，如果每个页面我们都要组合这些组件，写搜索逻辑，it’s waste;","categories":[],"tags":[{"name":"编程范式","slug":"编程范式","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"}]},{"title":"💻--M1芯片为什么这么快","slug":"💻--M1芯片为什么这么快","date":"2021-08-22T16:00:00.000Z","updated":"2022-06-10T01:04:40.247Z","comments":true,"path":"2021/undefined/22/💻--M1芯片为什么这么快/","link":"","permalink":"http://example.com/2021/undefined/22/%F0%9F%92%BB--M1%E8%8A%AF%E7%89%87%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/","excerpt":"","text":"1.采用ARM架构，采用了新的指令集 2.CPU，GPU，共用内存，减少总线带来的数据传输延迟 3.采用5nm技术，更多的二极管，更强大的运算量","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"📣🚦力扣刷题有感","slug":"📣🚦力扣刷题有感","date":"2021-08-15T16:00:00.000Z","updated":"2022-06-10T01:04:40.168Z","comments":true,"path":"2021/undefined/15/📣🚦力扣刷题有感/","link":"","permalink":"http://example.com/2021/undefined/15/%F0%9F%93%A3%F0%9F%9A%A6%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E6%9C%89%E6%84%9F/","excerpt":"","text":"1.非智力因素作为一个专业人士，要保持编码能力的一个方法就是经常做题，千难万难，坚持最难，训练韧性和耐力，戒骄戒躁，脚踏实地，注重非智力因素的培养。 2.迷宫写代码不能靠猜，更不能靠运气，用逻辑去思考，感觉自己以前纯粹是扣代码，蒙对了就过，蒙不对就在找原因，这是很low的阶段。计算好每一步，不能面向打印编程，有的人写代码就像走迷宫一样，这条路试一下，那条路试一下，试了很多路终于走出来了，下次再进入迷宫还是不知道怎么走，这样没有任何意义，我们要搞编制一副地图，靠地图走出来， 不断完善自己的地图，注重消化，学会为主，等有类似迷宫我们就查地图就可以了。 3.Deliberately practice功夫在文章外，靠纯粹写项目代码并不能提高代码本身的水平，多刷题，代码本身是算法的组合，刷题刻意训练思维逻辑。#### 4.实践多看好代码，如果仅靠自己关门造车，好前端是好项目煨出来的，可以多看看github一些高star项目的源代码，尝试写一些这样的项目，和letcode多做对比,这样才能不断汲取好的东西。 5.举一反三 提交通过只是完成了第一步，写出别的方法才是进步。 6.做项目和刷题的区别:- 做项目测试少，刷题有上千个测试case。- 做项目千篇一律，基本是cv，能跑就行，完全是为了完成任务。刷题要考虑复杂度，内存，更深入。- 做项目遇到问题的时候，就需要去权衡应该采用什么样的方式来解决具体的问题，但是如果写的项目代码只是仅仅满足于实现流程，不能对比不同实现方案之间的优缺点，那做项目确实对代码能力的成长是很局限的。- 项目更多的是应用领域，刷题是理论基础研究。就像蒸汽机应用于汽车，拓补学应用于人工智能。- 项目不够难，日常只有增删改查。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"-🗳🗳-npm发布，package-json,-版本自动控制","slug":"-🗳🗳-npm发布，package-json,-版本自动控制","date":"2021-08-14T16:00:00.000Z","updated":"2022-06-10T01:04:40.168Z","comments":true,"path":"2021/undefined/14/-🗳🗳-npm发布，package-json,-版本自动控制/","link":"","permalink":"http://example.com/2021/undefined/14/-%F0%9F%97%B3%F0%9F%97%B3-npm%E5%8F%91%E5%B8%83%EF%BC%8Cpackage-json,-%E7%89%88%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6/","excerpt":"","text":"###痛点npm 发包每次都手动改 version，好烦。。🤣 解决办法：Semantic versioningnpm version Patch在我们的package.json里面有一个version字段。 那么，怎么在项目不断构建的过程中调整版本呢？ npm有一套自己的版本控制标准——Semantic versioning（语义化版本） 具体体现为： 版本格式：主版本号 次版本号 修订号，版本号递增规则如下： 主版本号：patch，当你做了不兼容的 API 修改，次版本号：minor，当你做了向下兼容的功能性新增，修订号：major，当你做了向下兼容的问题修正。 自动改变版本 $ npm version &lt;update_type&gt; 参数update_type: patch(补丁), minor(小改), major(大改)例如：我原本的项目是1.0.0版本的话 patch &#x3D;&gt; 1.0.1 mino &#x3D;&gt; 1.1.0 major &#x3D;&gt; 2.0.0 npm hooknpm publish之后会调用 prepare命令，我们可以利用这个hook搞事情🤔 package.json: 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;NODE_ENV=production webpack --progress&quot;, &quot;prepare&quot;: &quot;npm run build &amp;&amp; npm --no-git-tag-version version patch&quot; &#125;,","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-js小技巧","slug":"🌦🌦-js小技巧","date":"2021-08-11T16:00:00.000Z","updated":"2022-06-10T01:04:40.168Z","comments":true,"path":"2021/undefined/11/🌦🌦-js小技巧/","link":"","permalink":"http://example.com/2021/undefined/11/%F0%9F%8C%A6%F0%9F%8C%A6-js%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"1.Array().fill 产生 n个数的数组 Array(length).fill(element) 参数length 填充长度element 用来填充数组元素的值。 1234 let codes = Array(26).fill(0).map((t,i) =&gt; i)console.log(codes) // [0,1,2,3,4,5,6......25] 2.reduce 求和let arr = [1, 2, 3]let sum = arr.reduce((pre, cur) =&gt; pre + cur, 0) // 6 PS 注意 空数组, 如果空元素 reduce 会报错 3.向数组指定位置插入元素splice() 方法 splice(startIndex,deleteNum,item)startIndex: 插入位置deleteNum: 删除数量item: 插入元素 splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。 方法实例:123456789// 在数组指定位置插入var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);//输出结果//Banana, Orange, Lemon, Kiwi, Apple, Mango//在 2 的位置删除0个，新增 &quot;Lemon&quot;, &quot;Kiwi&quot; 4. 删除最后一个字符串的方法stringObject.substr(start, length) 用于返回一个从指定位置开始的指定长度的子字符串。start（必需）：所需的子字符串的起始位置。字符串中的第一个字符的索引为 0。length（可选）：在返回的子字符串中应包括的字符个数。 1234字符串let basic = &quot;abc,def,ghi,&quot;; const newBasic = basic.substr(0, basic.length - 1); // abc,def,ghiconsole.log(basic) // &quot;abc,def,ghi,&quot;; 字符串方法 slice()、substring()、substr() 都不能改变原来的元素 5. ES6删除和过滤对象中部分属性原始数据 1234567let student=&#123; age: 20, name: &#x27;maomao&#x27;, sex: &quot;男&quot;&#125; 排除”age”属性 1234let &#123; age, ...params &#125; = studentconsole.log(params) // &#123;name: &quot;maomao&quot;，sex: &quot;男&quot;&#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"💻-cpu体系结构","slug":"💻-cpu体系结构","date":"2021-08-07T16:00:00.000Z","updated":"2022-06-10T01:04:40.246Z","comments":true,"path":"2021/undefined/07/💻-cpu体系结构/","link":"","permalink":"http://example.com/2021/undefined/07/%F0%9F%92%BB-cpu%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.按照架构区分，现在主流的CPU 分为ARM，X86两种。 架构 指令集 功耗 主要应用领域 ARM 精简 高 服务器，台式电脑，笔记本 X86 复杂 低 手机，新版mac 电脑，各种嵌入式设备 2.cpu物理组成1.寄存器2.控制器3.运算器4.计数器5.总线 3.芯片是怎么制造出来的一.沙子提纯二.光刻机光刻 3.1.芯片分类按照功能分类这种分类方式是也是大家最常见的，比如GPU，CPU，FPGA，DSP，ASIC，SOC等等，都是按照这个分类方式分类的 4.单核和多核有什么具体区别5.cpu运行与计算机数据结构指针，数组，栈结构，链表，数组，队列，二叉树都是以内存为基础的 6.不同CPU为什么在需要不同操作系统不同CPU架构指令集不同，在不同的机器上。操作系统会把把高级语言，或者汇编语言编译成对应的机器码","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"💻-操作系统-api应用","slug":"💻-操作系统-api应用","date":"2021-08-07T16:00:00.000Z","updated":"2022-06-10T01:04:40.246Z","comments":true,"path":"2021/undefined/07/💻-操作系统-api应用/","link":"","permalink":"http://example.com/2021/undefined/07/%F0%9F%92%BB-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-api%E5%BA%94%E7%94%A8/","excerpt":"","text":"1.录屏 直播原理调用录屏api2.调用时间 API3.地理定位4.网络抓包","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"🌦🌦-前端位运算","slug":"🌦🌦-前端位运算","date":"2021-08-04T16:00:00.000Z","updated":"2022-06-10T01:04:40.167Z","comments":true,"path":"2021/undefined/04/🌦🌦-前端位运算/","link":"","permalink":"http://example.com/2021/undefined/04/%F0%9F%8C%A6%F0%9F%8C%A6-%E5%89%8D%E7%AB%AF%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"一、定义 位运算符 符号 定义 或 | 两个位有一个为1，结果就是1，否则结果为0 非 ~ 如果位为0，结果是1，如果位为1，结果是0 异或 ^ 两个位相同结果为0，不同结果为1 二、实例 位运算符 实例 解析 与 128 &amp; 129 &#x3D;128 或 129 &#x3D; 129 非 ~128 &#x3D; -129 异或 128 ^ 129 &#x3D; 1","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦕🦕-react-高阶组件hotc和@装饰器","slug":"🦕🦕-react-高阶组件hotc和@装饰器","date":"2021-08-04T16:00:00.000Z","updated":"2022-06-10T01:04:40.167Z","comments":true,"path":"2021/undefined/04/🦕🦕-react-高阶组件hotc和@装饰器/","link":"","permalink":"http://example.com/2021/undefined/04/%F0%9F%A6%95%F0%9F%A6%95-react-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6hotc%E5%92%8C@%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"简介高阶组件可以直接调用子组件属性方法；子组件通过 this.props.xxx调用高阶组件方法属性 高阶组件无法修改子组件状态属性子组件无法修改高阶组件属性 高阶组件通俗讲是 代理模式的变种 高阶组件和装饰器1.高阶组件是react 组件，拥有react 组件各种属性（生命周期，state, render)装饰器没有 2.装饰器可以，修饰函数 和 react 组件 ，面向切面编程 3.都是代理模式的一种应用","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🟨-🟨-正则表达式中^的用法","slug":"🟨-🟨-正则表达式中^的用法","date":"2021-08-03T16:00:00.000Z","updated":"2022-06-10T01:04:40.241Z","comments":true,"path":"2021/undefined/03/🟨-🟨-正则表达式中^的用法/","link":"","permalink":"http://example.com/2021/undefined/03/%F0%9F%9F%A8-%F0%9F%9F%A8-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD^%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"用法一: 限定开头 文档上给出了解释是匹配输入的开始，如果多行标示被设置成了true，同时会匹配后面紧跟的字符。 比如 &#x2F;^A&#x2F;会匹配”An e”中的A，但是不会匹配”ab A”中的A 用法二：（否）取反当这个字符出现在一个字符集合模式的第一个字符时，他将会有不同的含义。 比如： &#x2F;[^a-z\\s]&#x2F;会匹配”my 3 sisters”中的”3” 这里的”^”的意思是字符类的否定，上面的正则表达式的意思是匹配不是（a到z和空白字符）的字符。 总结：什么时候”^”是否定字符，什么时候是匹配开始行 表示限定开头的示例：12345/[(^\\s+)(\\s+$)]/g(^cat)$(^cat$)^(cat)$^(cat$) 表示否定的示例：1234[^a]表示“匹配除了a的任意字符”。[^a-zA-Z0-9]表示“找到一个非字母也非数字的字符”。[\\^abc]表示“找到一个插入符或者a或者b或者c”。[^0-9] 匹配非数字 经过对比，只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头。我这里说的是直接在”[]”中使用，不包括嵌套使用。其实也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"📁📁-操作系统文件大小写的区别","slug":"📁📁-操作系统文件大小写的区别","date":"2021-08-01T16:00:00.000Z","updated":"2022-06-10T01:04:40.166Z","comments":true,"path":"2021/undefined/01/📁📁-操作系统文件大小写的区别/","link":"","permalink":"http://example.com/2021/undefined/01/%F0%9F%93%81%F0%9F%93%81-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"mac 文件，不区分大小写A.js &#x3D;&#x3D;&#x3D; a.js true 导致的问题是本地 引用不区分没问题 部署出现错误基本无解，只能尽量注意 linux 区分大小写A.js &#x3D;&#x3D;&#x3D; a.js false","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦--encodeURI与encodeURIComponent区别","slug":"🌦🌦--encodeURI与encodeURIComponent区别","date":"2021-07-29T16:00:00.000Z","updated":"2022-06-10T01:04:40.166Z","comments":true,"path":"2021/undefined/29/🌦🌦--encodeURI与encodeURIComponent区别/","link":"","permalink":"http://example.com/2021/undefined/29/%F0%9F%8C%A6%F0%9F%8C%A6--encodeURI%E4%B8%8EencodeURIComponent%E5%8C%BA%E5%88%AB/","excerpt":"","text":"语法 encodeURI(URI) decodeURI(URI) ex: 12encodeURI(&quot;陈振飞&quot;) //&#x27;%E9%99%88%E6%8C%AF%E9%A3%9E&#x27;decodeURI(&#x27;%E9%99%88%E6%8C%AF%E9%A3%9E&#x27;) // 陈振飞 编码原因:因为当字符串数据以url的形式传递给web服务器时,字符串中是不允许出现空格和特殊字符的 1.因为当字符串数据以url的形式传递给web服务器时,字符串中是不允许出现空格和特殊字符的比如说 传递邮箱这个字符串的时候 &#x68;&#x65;&#104;&#101;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#x6d; url中是不允许出现@字符的，转义之后会变成 hehe%40163.com 2.在标准的url规范中**中文**和很多的字符是不允许出现在url中的 encodeURI与encodeURIComponent区别encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent则会对它发现的任何非标准字符进行编码。 ex: 12345var uri=&quot;http://www.jxbh.cn/illegal value.htm#start&quot;;//”http://www.jxbh.cn/illegal%20value.htm#start”alert(encodeURI (uri))://”http%3A%2F%2Fwww.jxbh.cn%2Fillegal%20value.htm%23start”alert( encodaURIComponent (uri)); 使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-++a-,-a++-区别","slug":"🌦🌦-++a-,-a++-区别","date":"2021-07-24T16:00:00.000Z","updated":"2022-06-10T01:04:40.166Z","comments":true,"path":"2021/undefined/24/🌦🌦-++a-,-a++-区别/","link":"","permalink":"http://example.com/2021/undefined/24/%F0%9F%8C%A6%F0%9F%8C%A6-++a-,-a++-%E5%8C%BA%E5%88%AB/","excerpt":"","text":"相同点a++ 和 ++a的都是给a+1 不同点a++是先参加程序的运行再+1，而++a则是先+1再参加程序的运行。 Example：12345var a = 2； var b = a++； 运行后： b = 2，a =3 ； 12345var a = 2； var b = ++a； 运行后： b = 3，a =3； 1234567var a = 3;var goos = function()&#123; return a++;&#125; console.log(goos()); // 3 1234567var a = 3;var goos = function()&#123; return ++a;&#125; console.log(goos()); // 4","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-charCodeAt-,-fromCharCode-用法","slug":"🌦🌦-charCodeAt-,-fromCharCode-用法","date":"2021-07-23T16:00:00.000Z","updated":"2022-06-10T01:04:40.165Z","comments":true,"path":"2021/undefined/23/🌦🌦-charCodeAt-,-fromCharCode-用法/","link":"","permalink":"http://example.com/2021/undefined/23/%F0%9F%8C%A6%F0%9F%8C%A6-charCodeAt-,-fromCharCode-%E7%94%A8%E6%B3%95/","excerpt":"","text":"12let d = &quot;a&quot;console.log(d.charCodeAt()) // 97 12let num = String.fromCharCode(97)console.log(num) 97","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-js中-空值合并操作符(--),有哪些坑","slug":"🌦🌦-js中-空值合并操作符(--),有哪些坑","date":"2021-07-18T16:00:00.000Z","updated":"2022-06-10T01:04:40.165Z","comments":true,"path":"2021/undefined/18/🌦🌦-js中-空值合并操作符(--),有哪些坑/","link":"","permalink":"http://example.com/2021/undefined/18/%F0%9F%8C%A6%F0%9F%8C%A6-js%E4%B8%AD-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6(--),%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91/","excerpt":"","text":"空值合并操作符（??） 只有当左侧为null和undefined和空时，才会返回右侧的数,否则返回左侧的 重点: 0 除外 123let a = &quot;&quot;let result = a ?? &quot;target&quot;console.log(result) // &#x27;&#x27; 1234判断数组长度慎用let a = []let result = a.length === 0 ?? &quot;target&quot;console.log(result) true 123let number = 0;let result = number ?? 1console.log(result) // 0","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦数组删除某个下标对象","slug":"🌦🌦数组删除某个下标对象","date":"2021-07-15T16:00:00.000Z","updated":"2022-06-10T01:04:40.165Z","comments":true,"path":"2021/undefined/15/🌦🌦数组删除某个下标对象/","link":"","permalink":"http://example.com/2021/undefined/15/%F0%9F%8C%A6%F0%9F%8C%A6%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E4%B8%8B%E6%A0%87%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"1.splice splice(index, num)index: 下标num: 删除的数量@return 删除的元素 原来的数组会被修改 删掉第三个元素1234let dataSource = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]let newDataSource = dataSource.splice(2, 1);console.log(newDataSource) // [&quot;c&quot;]console.log(dataSource) // [&quot;a&quot;, &quot;b&quot;] 在for 循环使用比如要依次删除 dataSource中的元素 123456let dataSource = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for (let i = 0; i &lt; dataSource.length; i ++) &#123; dataSource.splice(i, 1) console.log(dataSource) // [&quot;b&quot;, &quot;c&quot;], [&quot;c&quot;] , [] i = i - 1 // 原来的元素被删掉需要往前一位&#125; 2.slice 2.slice(startIndex, endIndex)startIndex: 开始下标endIndex: 结束下标(不包含这个元素)@return 截取的元素 原来的数组不会被修改 1234let dataSource = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]let newDataSource = dataSource.slice(1,2);console.log(newDataSource) // [&quot;b&quot;]console.log(dataSource) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-优雅的获取-数组第一个元素","slug":"🌦🌦-优雅的获取-数组第一个元素","date":"2021-07-11T16:00:00.000Z","updated":"2022-06-10T01:04:40.164Z","comments":true,"path":"2021/undefined/11/🌦🌦-优雅的获取-数组第一个元素/","link":"","permalink":"http://example.com/2021/undefined/11/%F0%9F%8C%A6%F0%9F%8C%A6-%E4%BC%98%E9%9B%85%E7%9A%84%E8%8E%B7%E5%8F%96-%E6%95%B0%E7%BB%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"项目开发中经常会用到这样的操作 12345// 获取数组的第一个元素 const list = [&#x27;Luke&#x27;, &#x27;Eva&#x27;, &#x27;Phil&#x27;,&#x27;Tela&#x27;]; let data = list[0] let target = list[1] 缺点：在代码中出现数字，感觉这样写不够美观 第一种 shift()1234const list = [&#x27;Luke&#x27;, &#x27;Eva&#x27;, &#x27;Phil&#x27;,&#x27;Tela&#x27;]; let data = list.shift() // ”Luke“let target = list.shift() // ”Eva“ 优点：代码相对美观缺点： 会修改原数组 第二种, 使用 es6解构12345const list = [&#x27;Luke&#x27;, &#x27;Eva&#x27;, &#x27;Phil&#x27;,&#x27;Tela&#x27;]; const [first, second, third] = list;console.log(first, second); // &#x27;Luke&#x27; &#x27;Eva&#x27; console.log(third) // &quot;Phil&quot; &quot;Tela&quot; 到如今，已经知道了如何从数组中提取单个元素，那么对于想要取数组中的后面连续部分的元素怎么办呢？看下面的解构代码。 1234const list = [&#x27;Luke&#x27;, &#x27;Eva&#x27;, &#x27;Phil&#x27;,&#x27;Tela&#x27;]; var [first, ...rest] = list; console.log(rest); // [&#x27;Eva&#x27;,&#x27;Phil&#x27;]","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🟨-🟨--常用正则表达式","slug":"🟨-🟨--常用正则表达式","date":"2021-06-28T16:00:00.000Z","updated":"2022-06-10T01:04:40.241Z","comments":true,"path":"2021/undefined/28/🟨-🟨--常用正则表达式/","link":"","permalink":"http://example.com/2021/undefined/28/%F0%9F%9F%A8-%F0%9F%9F%A8--%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"常用正则表达式1.数字，保留两位小数1^(([1-9]&#123;1&#125;\\d*)|(0&#123;1&#125;))(\\.\\d&#123;0,2&#125;)?$ 12342.22, true2.0 true2 true2.222 false 1.1.有效数字，不以0结尾1let reg = /^(([1-9]&#123;1&#125;\\d*)|(0&#123;1&#125;))(\\.\\d*[1-9]+)?$/; 12342.20 false2.22 true2 true2.222 true 2.连续相同字符1^(.)\\1&#123;1&#125; 123let s = &quot;aaabbcde&quot;s.match(/(.)\\1*/g);[&quot;aaa&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;] 3.奇数1/^\\d?[13579]$/ 4.以某个字符开头的字符12onst reg = new RegExp(`(?&lt;=$&#123;str&#125;)\\\\w+`, &#x27;g&#x27;);(?&lt;=$&#123;str&#125;) 以某个字符开头 方法1.replace 语法 str.replace(regexp|substr, newSubStr|function) 12let ex = &quot;aadcd&quot;;ex = ex.replace(&#x27;a&#x27;,1) // &quot;1adcd&quot; 12let ex = &quot;aadcd&quot;;ex = ex.replace(/a/g,1) // &quot;11dcd&quot; 12345678let obj = &#123;a: 1, b: 2&#125;let ex = &quot;aadcd&quot;;ex = ex.replace(/a/g, (match ,offset) =&gt; &#123; console.log(match) // 匹配对象 console.log(offset) // 下标 return obj[match]&#125;)console.log(ex) // &quot;11dcd&quot; 2.replaceAllES2021新特性-替换一个字符串中的所有指定字符 replaceAll()方法的使用String.protype.replaceAll 在 ES2021 之前 123const str = &#x27;2-4-6-8-10&#x27;;const newStr = str.replace(/\\-/g, &#x27;+&#x27;);console.log(newStr); //2+4+6+8+10 ES2021 之后： 123const str = &#x27;2-4-6-8-10&#x27;;const newStr = str.replaceAll(&#x27;-&#x27;, &#x27;+&#x27;);console.log(newStr); //2+4+6+8+10 在正则中使用变量12let pre = &quot;flo&quot;let reg = new RegExp(`$&#123;pre&#125;`) 基础知识正则只能用于匹配，不能用于计算 123456789.匹配除换行符以外的任意字符\\w 匹配字母或数字或下划线或汉字 等价于 ‘[A-Za-z0-9_]’。\\s 匹配任意的空白符\\d 匹配数字+ 表示重复一次或者多次?表示重复0次或1次（最多1次）；* 表示重复零次或者多次&#123;n,m&#125; 表示n 到 m 次/\\XX/g 全局替换","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"🌦🌦-js-二进制转字符串","slug":"🌦🌦-js-二进制转字符串","date":"2021-04-27T16:00:00.000Z","updated":"2022-06-10T01:04:40.164Z","comments":true,"path":"2021/undefined/27/🌦🌦-js-二进制转字符串/","link":"","permalink":"http://example.com/2021/undefined/27/%F0%9F%8C%A6%F0%9F%8C%A6-js-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"十进制转二进制12let num = 5;num = num.toString(2) // &quot;101&quot; 二进制转十进制 parseInt(string, radix)radix：该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN 12let num = &quot;101&quot;num = parseInt(num, 2); // 5","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🧮-🧮-查找树节点中符合条件的子节点","slug":"🧮-🧮-查找树节点中符合条件的子节点","date":"2021-04-18T16:00:00.000Z","updated":"2022-06-10T01:04:40.163Z","comments":true,"path":"2021/undefined/18/🧮-🧮-查找树节点中符合条件的子节点/","link":"","permalink":"http://example.com/2021/undefined/18/%F0%9F%A7%AE-%F0%9F%A7%AE-%E6%9F%A5%E6%89%BE%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AD%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9/","excerpt":"","text":"1.查找一个 12345678910111213let filterTreeId = (list, id) =&gt; &#123; let targetObj = null; for (const item of list) &#123; if (item.id === id) &#123; targetObj = item; break; &#125; if (item.childList &amp;&amp; item.childList.length) &#123; targetObj = filterTreeId(item.childList, id); &#125; &#125; return targetObj; &#125;, 2.查找多个 123456789101112131415let filterTreeIdList = (List, id) =&gt; &#123; let setList = []; for (const item of List) &#123; if (item.id === id) &#123; setList.push(item); &#125; if (item.childList &amp;&amp; item.childList.length &gt;= 1) &#123; setList = [ ...setList, ...filterTreeIdList(item.childList, id) ]; &#125; &#125; return setList; &#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦜🦜vue-修改数组中某个对象的属性","slug":"🦜🦜vue-修改数组中某个对象的属性","date":"2021-03-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.163Z","comments":true,"path":"2021/undefined/10/🦜🦜vue-修改数组中某个对象的属性/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%A6%9C%F0%9F%A6%9Cvue-%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"比如要有如下数组 123456789101112131415data() &#123; return &#123; certificateData: [ &#123; name: &#x27;xxx&#x27;, type: &#x27;环境证书&#x27;, imgs:[&#123;url: &#x27;xxxx.png&#x27;] &#125;, &#123; name: &#x27;yyy&#x27;, type: &#x27;安全证书&#x27;, imgs:[&#123;url: &#x27;yyy.png&#x27;&#125;] &#125; ]&#125; 修改对象中 imgs属性 12345/// index为索引this.$set(this.certificateData, index, &#123; ...this.certificateData[index], imgs: [&#123;url:&#x27;zzz.png;&#125;]&#125;);","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-forEach不改变原数组,-但是改变对象属性的问题","slug":"🌦🌦-forEach不改变原数组,-但是改变对象属性的问题","date":"2021-03-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.163Z","comments":true,"path":"2021/undefined/10/🌦🌦-forEach不改变原数组,-但是改变对象属性的问题/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8C%A6%F0%9F%8C%A6-forEach%E4%B8%8D%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84,-%E4%BD%86%E6%98%AF%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.forEach(item, index, arr)，三个参数，如果直接用item&#x3D;xxx是无法改变原数组的，但是如果用arr[index]就可以改变原数组。1234567891011121314 var s = [1, 2, 3, 4];// 未改变原数组s.forEach(item=&gt;&#123; item = &#x27;a&#x27;&#125;);console.log(s); // [1, 2, 3, 4] // 改变了原数组s.forEach((item, index, arr)=&gt;&#123; arr[index] = &#x27;b&#x27;&#125;);console.log(s); // [&quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;] 2.数组里面的子元素是对象，那么是可以改变对应属性的1234567891011121314// 未改变原数组var s = [&#123;a:1&#125;, &#123;a:1&#125;];s.forEach(item=&gt;&#123; item = null;&#125;);console.log(s); // [&#123;a: 1&#125; ,&#123;a: 1&#125;] // 改变的原数组里面的对象属性s.forEach(item=&gt;&#123; item.a = 666;&#125;);console.log(s); // [&#123;a: 666&#125;, &#123;a: 666&#125;]","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📁📁-CentOS-7-firewall-cmd开放端口时出现bad-port-(most-likely-missin","slug":"📁📁-CentOS-7-firewall-cmd开放端口时出现bad-port-(most-likely-missin","date":"2021-02-02T16:00:00.000Z","updated":"2022-06-10T01:04:40.162Z","comments":true,"path":"2021/undefined/02/📁📁-CentOS-7-firewall-cmd开放端口时出现bad-port-(most-likely-missin/","link":"","permalink":"http://example.com/2021/undefined/02/%F0%9F%93%81%F0%9F%93%81-CentOS-7-firewall-cmd%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E6%97%B6%E5%87%BA%E7%8E%B0bad-port-(most-likely-missin/","excerpt":"","text":"使用firewall-cmd命令打开端口时遇到了”bad port (most likely missing protocol), correct syntax is portid[-portid]&#x2F;protocol”这个问题。 百度了下没解决方案，又看了一遍错误提示和输入的命令后被自己蠢哭了 废话不多说，问题的原因是命令中add-port参数值的正确格式为[端口号&#x2F;协议]，而当前执行的命令中只写了端口号，没有指定协议 正确的命令为: firewall-cmd –zone&#x3D;public –add-port&#x3D;8020&#x2F;tcp –permanent 当然之后别忘记 firewall-cmd –reload 重启防火墙","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎨🎨-git-Tips","slug":"🎨🎨-git-Tips","date":"2021-02-01T16:00:00.000Z","updated":"2022-06-10T01:04:40.100Z","comments":true,"path":"2021/undefined/01/🎨🎨-git-Tips/","link":"","permalink":"http://example.com/2021/undefined/01/%F0%9F%8E%A8%F0%9F%8E%A8-git-Tips/","excerpt":"","text":"忽略文件对于未入库的文件touch .gitignore 在文件中写入需要忽略的文件（如：*.diff ……具体见链接），或者不遵循忽略原则的特例（文件前加“！”） （注：只对untracked files有效） 对于已入库的文件git update-index --assume-unchanged $path + $file 若以后不想忽略该文件的修改，则输入命令：git update-index --no-assume-unchanged $path + $file stash 单个文件$ git stash push -m &quot;message&quot; file_path","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦜🦜vue-对象的属性是数组-watch监听不了","slug":"🦜🦜vue-对象的属性是数组-watch监听不了","date":"2021-01-16T16:00:00.000Z","updated":"2022-06-10T01:04:40.099Z","comments":true,"path":"2021/undefined/16/🦜🦜vue-对象的属性是数组-watch监听不了/","link":"","permalink":"http://example.com/2021/undefined/16/%F0%9F%A6%9C%F0%9F%A6%9Cvue-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E6%95%B0%E7%BB%84-watch%E7%9B%91%E5%90%AC%E4%B8%8D%E4%BA%86/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849data() &#123; formData: &#123; areaId: 14, isNew: true, isDraft: false, cName: &#x27;&#x27;, costRate: 0, price: 0, grammage: 0, pictureUri: &#x27;&#x27;, testArr: [], materialListOrigin: [] &#125;,&#125;, watch: &#123; &quot;formData.materialListOrigin&quot;: &#123; handler(v) &#123; debugger let r = v.reduce((sum, item) =&gt; &#123; sum += item.needWeight * item.unitPrice; return sum; &#125;, 0); this.formData.price = fixedPoint(r, 2); let s = v.reduce((sum, item) =&gt; &#123; if (item.isWeight) &#123; sum += item.productWeight; &#125; return sum &#125;, 0); if (this.dishesName === &#x27;小吃类&#x27;) &#123; this.formData.grammage = 0; return; &#125; // 成品克数 this.formData.grammage = fixedPoint(s, 0); &#125;, deep: true &#125;, &#125;,methods() &#123; // 新增菜品保存 saveMateRiarl(name) &#123; this.$refs[name].validate((valid) =&gt; &#123; if (!valid) return; this.formData.materialListOrigin.push(this.formValidateMetarial); &#125;) &#125;,&#125; 问题， this.formData.materialListOrigin.push，watch 不会触发。原因：对象下的属性是数组，watch不了解决方法：直接监听对象 12345678910111213141516171819202122232425watch: &#123; formData: &#123; handler(w) &#123; let v = w.materialListOrigin; let r = v.reduce((sum, item) =&gt; &#123; sum += item.needWeight * item.unitPrice; return sum; &#125;, 0); this.formData.price = fixedPoint(r, 2); let s = v.reduce((sum, item) =&gt; &#123; if (item.isWeight) &#123; sum += item.productWeight; &#125; return sum &#125;, 0); if (this.dishesName === &#x27;小吃类&#x27;) &#123; this.formData.grammage = 0; return; &#125; // 成品克数 this.formData.grammage = fixedPoint(s, 0); &#125;, deep: true &#125;, &#125;,","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🎨🎨-git-设置文件大小写敏感","slug":"🎨🎨-git-设置文件大小写敏感","date":"2021-01-14T16:00:00.000Z","updated":"2022-06-10T01:04:40.099Z","comments":true,"path":"2021/undefined/14/🎨🎨-git-设置文件大小写敏感/","link":"","permalink":"http://example.com/2021/undefined/14/%F0%9F%8E%A8%F0%9F%8E%A8-git-%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/","excerpt":"","text":"方法一命令设置Git大小写敏感： 1git config core.ignorecase false 方法二找到项目的 .git 文件夹（window默认是隐藏的，设置显示隐藏的项目即可出现） 下的 config 文件打开，将 ignorecase &#x3D; true 设置成 ignorecase &#x3D; false git文件大小写敏感导致的问题，在有些mac上，文件大小写是不敏感的。 比如两个同学，小a的电脑大小写不敏感，小b的电脑大小写敏感。1.小a 提交了一个 文件 Out.vue, 路径&#x2F;admin&#x2F;out.vue 2.小b拉pull 代码，结果路径找不到文件。 3.小b找小a,让小a把Out.vue 改成 out.vue 4.小a 本地git 大小写不敏感，修改文件，发现git add 发现没有任何修改 5.设置git 大小写敏感，代码问题解决。 6.为了避免类似问题再次发生，小a需要把电脑设置为大小写敏感 设置mac 系统为大小写敏感(https://www.jianshu.com/p/24fd2a0ae493)","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌈-flex布局--一行显示固定个数,强制换行且均匀分布","slug":"🌈-flex布局--一行显示固定个数,强制换行且均匀分布","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.091Z","comments":true,"path":"2021/undefined/10/🌈-flex布局--一行显示固定个数,强制换行且均匀分布/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8C%88-flex%E5%B8%83%E5%B1%80--%E4%B8%80%E8%A1%8C%E6%98%BE%E7%A4%BA%E5%9B%BA%E5%AE%9A%E4%B8%AA%E6%95%B0,%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%94%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83/","excerpt":"","text":"12345/* flex-direction 决定主轴的方向 row(默认)|row-reverse|column|column-reverse*//* flex-direction: row; *//* flex-wrap决定当排列不下时是否换行以及换行的方式,nowrap(默认)|wrap|wrap-reverse *//* flex-wrap:wrap; */ 12345678910111213141516171819202122232425262728293031--html &lt;ul class=&#x27;upload-item&#x27;&gt; &lt;Form ref=&quot;formInline&quot; :model=&quot;formInline&quot; :label-width=&#x27;152&#x27;&gt; &lt;li v-for=&#x27;(v, i) in formInline.testLists&#x27;&gt; &lt;FormItem :label=&#x27;v.name&#x27; style=&#x27;display:flex;&#x27; &gt; &lt;Upload ref=&quot;uploadFoods&quot; :accept=&#x27;accept&#x27; :default-file-list=&quot;v.list&quot; :on-success=&quot;foodLicenceHandleSuccess.bind(null, &#123;&#x27;index&#x27;:i,&#x27;data&#x27;:v&#125;)&quot; :on-error=&quot;handleError&quot; :max-size=&quot;2048 * 4&quot; :headers=&quot;fileHeader&quot; :before-upload=&quot;handleBeforeUpload&quot; action=&quot;/adminapi/file/upload&quot; &gt; &lt;div style=&quot;display: flex; align-items:center;cursor: pointer;&quot;&gt; &lt;img class=&quot;upload-icon&quot; src=&quot;@/assets/images/register/add.png&quot; width=&quot;20&quot; /&gt; &lt;p class=&quot;upload-box-action&quot;&gt;上传文件&lt;/p&gt; &lt;/div&gt; &lt;/Upload&gt; &lt;/FormItem&gt; &lt;/li&gt; &lt;/Form&gt; &lt;/ul&gt; 123456789101112131415---css.mycards&#123; // 大盒子 width: 98%; display: flex; flex-wrap: wrap; // 换行 justify-content: space-between;&#125;.card_item&#123; // 每个item flex: 1; width: 33.3%; min-width: 33.3%; // 加入这两个后每个item的宽度就生效了 max-width: 33.3%; // 加入这两个后每个item的宽度就生效了 height: 350px; &#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"🍎🍎-Mac-OS-配置环境变量","slug":"🍎🍎-Mac-OS-配置环境变量","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.093Z","comments":true,"path":"2021/undefined/10/🍎🍎-Mac-OS-配置环境变量/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8D%8E%F0%9F%8D%8E-Mac-OS-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"Mac端环境变量配置Mac使用bash做为默认的shell MAC OS X环境配置的加载顺序 123456# 系统级别/etc/profile/etc/paths # 用户级别~/.zshrc 前两个是系统级别的环境变量，针对所有用户，后面四个带有~&#x2F;用户级别的环境变量。-前两个环境配置在系统启动时候就会加载。 ~&#x2F;.zshrc 是zsh shell打开时候加载 之前mac 是使用bash新版本mac默认使用zsh，所以配置的.bash_profile不能生效，需要再配置.zshrc（新建.zshrc）配置内容： 123if [ -f ~/.bash_profile ]; thensource ~/.bash_profilefi","categories":[],"tags":[{"name":"mac小天地","slug":"mac小天地","permalink":"http://example.com/tags/mac%E5%B0%8F%E5%A4%A9%E5%9C%B0/"}]},{"title":"🌈-让div填充剩余的屏幕空间的高度","slug":"🌈-让div填充剩余的屏幕空间的高度","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.092Z","comments":true,"path":"2021/undefined/10/🌈-让div填充剩余的屏幕空间的高度/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8C%88-%E8%AE%A9div%E5%A1%AB%E5%85%85%E5%89%A9%E4%BD%99%E7%9A%84%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%9A%84%E9%AB%98%E5%BA%A6/","excerpt":"","text":"flex父元素设置 flex-flow: column; 垂直排列再使用 flex 自适应布局 calc height: calc(100% - 50px);剩余高度 &#x3D; 父元素高度 - 已有高度 demo https://codepen.io/qiudaoermu/pen/mdwPWVx","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"🍎🍎-Mac-Tips","slug":"🍎🍎-Mac-Tips","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.093Z","comments":true,"path":"2021/undefined/10/🍎🍎-Mac-Tips/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8D%8E%F0%9F%8D%8E-Mac-Tips/","excerpt":"","text":"Mac关闭指定端口先执行如下命令 1lsof -i:端口号 会有类似下面的结果：然后执行： 1kill -9 42624 结束进程就搞定了 Mac 终端开启和关闭代理的方法假如你的代理机是你的本机（127.0.0.1），代理的端口为 7070， 开启代理很简单，就是用 export 命令设置全局变量 http_proxy 和 https_proxy： 12export http_proxy=&quot;http://127.0.0.1:7070&quot;export https_proxy=&quot;http://127.0.0.1:7070&quot; 关闭代理就是用 unset 命令把全局变量清空： $ unset http_proxy $ unset ftp_proxy $ unset all_proxy $ unset https_proxy $ unset no_proxy 查看是否还存在代理 1env | grep -i proxy ps : 清空代理需要重新打开 terminal","categories":[],"tags":[{"name":"mac小天地","slug":"mac小天地","permalink":"http://example.com/tags/mac%E5%B0%8F%E5%A4%A9%E5%9C%B0/"}]},{"title":"ivew-动态新增-input-prop校验","slug":"ivew-动态新增-input-prop校验","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.238Z","comments":true,"path":"2021/undefined/10/ivew-动态新增-input-prop校验/","link":"","permalink":"http://example.com/2021/undefined/10/ivew-%E5%8A%A8%E6%80%81%E6%96%B0%E5%A2%9E-input-prop%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"有这样的需求如下图：1.下拉选择select 选择，2.新增一组 input提交选项 新增input代码如下(只罗列了前两项)： 12345678910111213 &lt;!-- 新增园区 --&gt;&lt;div v-for=&quot;(item, index) in formData.areaList&quot; v-if=&#x27;formData.areaList.length &gt;=1&#x27;&gt; &lt;div class=&quot;form-line&quot;&gt; &lt;FormItem label=&quot;联系人&quot; :prop=&quot;&#x27;areaList.&#x27; + index + &#x27;.contactor&#x27;&quot; :rules=&#x27;rules.contactor&#x27;&gt; &lt;Input v-model=&quot;item.contactor&quot; placeholder=&quot;请输入联系人&quot; clearable :style=&quot;&#123;width: &#x27;100%&#x27;&#125;&quot;&gt; &lt;/Input&gt; &lt;/FormItem&gt; &lt;FormItem label=&quot;联系电话&quot; :prop=&quot;&#x27;areaList.&#x27; + index + &#x27;.contactTel&#x27;&quot; :rules=&#x27;rules.contactTel&#x27;&gt; &lt;Input v-model=&quot;item.contactTel&quot; placeholder=&quot;请输入联系电话&quot; clearable :style=&quot;&#123;width: &#x27;100%&#x27;&#125;&quot;&gt; &lt;/Input&gt; &lt;/FormItem&gt; &lt;/div&gt;&lt;/div&gt; prop这样写 1:prop = areaList.&#x27; + index + &#x27;.contactor #####总结 ： 便利对象 + . + index + . + key####需要注意的点######1. prop现在是变量 前面加：######2.便利的数组对象(areaList), 要在需要最后提交的formData里######3.单独在新增的FormItem 加rules,比如 :rules&#x3D;’rules.contactor’ 1234567891011rules: &#123; contactor: [&#123; required: true, message: &#x27;请输入联系人&#x27;, trigger: &#x27;blur&#x27; &#125;], contactTel: [&#123; required: true, message: &#x27;请输入联系电话&#x27;, trigger: &#x27;blur&#x27; &#125;, ######4.新增的数组里需要加入 对应的key 如下: 12345let o = &#123; contactTel: &#x27;&#x27;, contactor: &#x27;&#x27; &#125; this.formData.areaList.push(o)","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"ivew-modal-验证，关闭再打开，验证错误","slug":"ivew-modal-验证，关闭再打开，验证错误","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.237Z","comments":true,"path":"2021/undefined/10/ivew-modal-验证，关闭再打开，验证错误/","link":"","permalink":"http://example.com/2021/undefined/10/ivew-modal-%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%85%B3%E9%97%AD%E5%86%8D%E6%89%93%E5%BC%80%EF%BC%8C%E9%AA%8C%E8%AF%81%E9%94%99%E8%AF%AF/","excerpt":"","text":"ivew 里弹框存在表单验证时，再次打开出现校验问题； 1用 v-if 把modal内容包起来 2.把 visable放在 12345678this.formData = &#123;key: value,.....&#125;this.$nextTick(() =&gt; &#123; this.visable = true;&#125;)","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"ivew-动态新增-input--v-model绑定","slug":"ivew-动态新增-input--v-model绑定","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.238Z","comments":true,"path":"2021/undefined/10/ivew-动态新增-input--v-model绑定/","link":"","permalink":"http://example.com/2021/undefined/10/ivew-%E5%8A%A8%E6%80%81%E6%96%B0%E5%A2%9E-input--v-model%E7%BB%91%E5%AE%9A/","excerpt":"","text":"有这样的需求如下图：1.下拉选择select 选择，2.新增一组 input提交选项 新增input代码如下(只罗列了前两项)： 12345678910111213 &lt;!-- 新增园区 --&gt;&lt;div v-for=&quot;(item, index) in formData.areaList&quot; v-if=&#x27;formData.areaList.length &gt;=1&#x27;&gt; &lt;div class=&quot;form-line&quot;&gt; &lt;FormItem label=&quot;联系人&quot; &gt; &lt;Input v-model=&quot;item.contactor&quot; placeholder=&quot;请输入联系人&quot; clearable :style=&quot;&#123;width: &#x27;100%&#x27;&#125;&quot;&gt; &lt;/Input&gt; &lt;/FormItem&gt; &lt;FormItem label=&quot;联系电话&quot; &gt; &lt;Input v-model=&quot;item.contactTel&quot; placeholder=&quot;请输入联系电话&quot; clearable :style=&quot;&#123;width: &#x27;100%&#x27;&#125;&quot;&gt; &lt;/Input&gt; &lt;/FormItem&gt; &lt;/div&gt;&lt;/div&gt; v-model 1v-model =&quot;item.contactor&quot; #####总结 ：item. + key","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"ivew-radio-单选-1,0-字符串和数字怎么传","slug":"ivew-radio-单选-1,0-字符串和数字怎么传","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.237Z","comments":true,"path":"2021/undefined/10/ivew-radio-单选-1,0-字符串和数字怎么传/","link":"","permalink":"http://example.com/2021/undefined/10/ivew-radio-%E5%8D%95%E9%80%89-1,0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E6%80%8E%E4%B9%88%E4%BC%A0/","excerpt":"","text":"字符串,label不用加: 123456789101112131415161718192021&lt;template&gt; &lt;RadioGroup v-model=&quot;hasDelay&quot;&gt; &lt;Radio label=1&gt;是&lt;/Radio&gt; &lt;Radio label=0&gt;否&lt;/Radio&gt; &lt;/RadioGroup&gt;&lt;/template&gt;&lt;script&gt; export default &#123; watch: &#123; hasDelay(v) &#123; console.log(v) &#125; &#125;, data () &#123; return &#123; hasDelay: &#x27;0&#x27; &#125; &#125; &#125;&lt;/script&gt; 数字 123456789101112131415161718192021&lt;template&gt; &lt;RadioGroup v-model=&quot;hasDelay&quot;&gt; &lt;Radio :label=1&gt;是&lt;/Radio&gt; &lt;Radio :label=0&gt;否&lt;/Radio&gt; &lt;/RadioGroup&gt;&lt;/template&gt;&lt;script&gt; export default &#123; watch: &#123; hasDelay(v) &#123; console.log(v) &#125; &#125;, data () &#123; return &#123; hasDelay: 0 &#125; &#125; &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"微信小程序-为什么地图本地体验可以用，线上环境不能用","slug":"微信小程序-为什么地图本地体验可以用，线上环境不能用","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.238Z","comments":true,"path":"2021/undefined/10/微信小程序-为什么地图本地体验可以用，线上环境不能用/","link":"","permalink":"http://example.com/2021/undefined/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%B0%E5%9B%BE%E6%9C%AC%E5%9C%B0%E4%BD%93%E9%AA%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%EF%BC%8C%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E4%B8%8D%E8%83%BD%E7%94%A8/","excerpt":"","text":"需要加安全域名 在你已经加的域名上增加https://apis.map.qq.com;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"怎么避免ivew-form-prop,-乱七八糟的type校验","slug":"怎么避免ivew-form-prop,-乱七八糟的type校验","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.239Z","comments":true,"path":"2021/undefined/10/怎么避免ivew-form-prop,-乱七八糟的type校验/","link":"","permalink":"http://example.com/2021/undefined/10/%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8Divew-form-prop,-%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84type%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"ivew 在参考(其实就是抄袭，api都一样)element的过程中，设置了一些独有的api比如，在form input校验中，设置了type,比如 1234567 &lt;Form :model=&quot;formValidate&quot; :rules=&quot;ruleValidate&quot; &gt; &lt;DatePicker type=&quot;date&quot; placeholder=&quot;Select date&quot; v- model=&quot;formValidate.date&quot;&gt; &lt;/DatePicker&gt;&lt;/Form&gt; 一个很简单的日期填写校验，rules如下 12345678ruleValidate: &#123; date: [&#123; required: true, type: &#x27;date&#x27;, message: &#x27;Please select the date&#x27;, trigger: &#x27;change&#x27; &#125;] &#125; type:’data’是什么意思，这个组件选择之后肯定是个data，这样的校验有什么意义呢。对于这种类型的校验，统一处理方法pattern: &#x2F;.+&#x2F; , 代替 tpye:’data’ 123456date: [&#123; required: true, pattern: /.+/ , message: &#x27;Please select the date&#x27;, trigger: &#x27;change&#x27; &#125;] 最后希望这个框架早点下架吧，这种反人性的UI框架对开发者来说就是灾难。有这功夫去做点有意义的事更划算。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🐛-An-error-occurred-while-installing-http_parser-rb-(0-6-0),-and-Bundl","slug":"🐛-An-error-occurred-while-installing-http_parser-rb-(0-6-0),-and-Bundl","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.240Z","comments":true,"path":"2021/undefined/10/🐛-An-error-occurred-while-installing-http_parser-rb-(0-6-0),-and-Bundl/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%90%9B-An-error-occurred-while-installing-http_parser-rb-(0-6-0),-and-Bundl/","excerpt":"","text":"问题 $ bundle install 1234567An error occurred while installing http_parser.rb (0.6.0), and Bundler cannot continue.In Gemfile: jekyll was resolved to 4.2.1, which depends on em-websocket was resolved to 0.5.2, which depends on http_parser.rb 打开错误日志 12&quot;pkg-config --exists openssl&quot; package configuration for openssl is not found 原因：没有正确设置PATH导致的问题mac 使用默认的ruby 版本，要更新最新版本 ruby 并且覆盖 解决方法:$ brew install ruby $ brew link --overwrite ruby 123456789If you need to have ruby first in your PATH run:echo &#x27;export PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrcFor compilers to find ruby you may need to set:export LDFLAGS=&quot;-L/usr/local/opt/ruby/lib&quot;export CPPFLAGS=&quot;-I/usr/local/opt/ruby/include&quot;For pkg-config to find ruby you may need to set: export PKG_CONFIG_PATH=&quot;/usr/local/opt/ruby/lib/pkgconfig&quot; 在 .zshrc 加入 ‘export PATH&#x3D;”&#x2F;usr&#x2F;local&#x2F;opt&#x2F;ruby&#x2F;bin:$PATH”‘ $ source ~/.zshrc","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"清明节,今天想跟自己谈谈.html","slug":"清明节,今天想跟自己谈谈","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.239Z","comments":true,"path":"2021/undefined/10/清明节,今天想跟自己谈谈/","link":"","permalink":"http://example.com/2021/undefined/10/%E6%B8%85%E6%98%8E%E8%8A%82,%E4%BB%8A%E5%A4%A9%E6%83%B3%E8%B7%9F%E8%87%AA%E5%B7%B1%E8%B0%88%E8%B0%88/","excerpt":"","text":"清明节,今天想跟自己谈谈 body { margin: 0; font-family: \"Helvetica Neue\", Helvetica, Arial, \"Hiragino Sans GB\", sans-serif; font-size: 14px; line-height: 20px; color: #777; background-color: white; } .container { width: 700px; margin-right: auto; margin-left: auto; } .post { font-family: Georgia, \"Times New Roman\", Times, \"SimSun\", serif; position: relative; padding: 70px; bottom: 0; overflow-y: auto; font-size: 16px; font-weight: normal; line-height: 25px; color: #515151; } .post h1{ font-size: 50px; font-weight: 500; line-height: 60px; margin-bottom: 40px; color: inherit; } .post p { margin: 0 0 35px 0; } .post img { border: 1px solid #D9D9D9; } .post a { color: #28A1C5; } 清明节,今天想跟自己谈谈 今天是2020年的清明节，今年发生了很多事，走了很多人，自己这两年也有很多变化，不论身体还是精神都是这样，过年的时候奶奶走了，心脏病很突然，大哥在微信的跟我说的时候内心还是不相信，奶奶八十多岁了，头上一根白头发都没有，真的很突然。毕业6年来，爷爷，姥姥，奶奶，没有了老一辈的人，突然感觉自己不再是个少年了。以前觉得人不会死，现在才发现，这是必经之路。前几天听说司徒正美因为脊椎病突然去世了，应该叫猝死吧,顺手翻了翻这位大神的知乎，看他的回答这个人正在走在财务自由的路上，起码物质不缺乏，他只比我大两岁，也是没成家，一阵唏嘘，如果他有老婆，应该不会走的这么突然吧，起码身边有个人会照顾他，自己这两年颈椎也不太好，这应该是程序员的通病吧。昨天坐在电脑前，看了会东西，颈椎就会不舒服的很，但是没工作没法生存，可能人生是需要不断平衡吧，以后还是要多锻炼啊，司徒最可悲的应该是人走了，钱没花了。现在发现对技术的热情好像减退很多。想想毕业这几年，14年去北京的时候还是个小屁孩，那时候主要注意力好像都放在了找女朋友上，现在想想真是傻啊，如果多放点精力在工作上，现在也不至于如此潦倒了。需要反思的东西太多太多，人还是需要脚踏实地一点，想想这些年爱过的人，恨过的人，放弃的人，离开的人。一切都是浮云吧，到头来能陪你走下去的还是喜欢你的人吧。已经年过30的人了，但是希望一切还不是太晚吧。来青岛已经差不多一个月，现在每天都在回北京还是留在青岛两条路中犹豫，想想自己十几万的欠款，这个决定真的不好下，疫情这么严重，心里非常乱，希望赶紧结束吧。","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"📣▶️-33届前端早早聊，总结","slug":"📣▶️-33届前端早早聊，总结","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.240Z","comments":true,"path":"2021/undefined/10/📣▶️-33届前端早早聊，总结/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%93%A3%E2%96%B6%EF%B8%8F-33%E5%B1%8A%E5%89%8D%E7%AB%AF%E6%97%A9%E6%97%A9%E8%81%8A%EF%BC%8C%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.设计层 &gt; 代码层2.focus on thinking and design3.掌握好基础，编译原理，数据结构与算法 大圣专场 招式需要找人练，内功自己打坐 一段时间只专注于一种技术 了解历史，掌握未来 高效研发，复杂场景， 算法， 操作系统1.每个需求都做出亮点懒加载 。。。企业级软件质量2.高效研发统一规范 ，eslint, git commit, 分支，发布部署，代码风格基建 快速迭代部署，lower code3.心法原理源码 沉底最佳实践设计 设计模式 基础世界玩法不会变阅读源码 从早期release版本开始看，follow作者博客，了解作者思想不要尝试蹦到6层楼，先跳到2、3层算法 + 数据结构 + 编译原理 &#x3D; 工程化","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"☀️☀️-编程范式----JS-必包-VS-c语言","slug":"☀️☀️-编程范式----JS-必包-VS-c语言","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.244Z","comments":true,"path":"2021/undefined/10/☀️☀️-编程范式----JS-必包-VS-c语言/","link":"","permalink":"http://example.com/2021/undefined/10/%E2%98%80%EF%B8%8F%E2%98%80%EF%B8%8F-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F----JS-%E5%BF%85%E5%8C%85-VS-c%E8%AF%AD%E8%A8%80/","excerpt":"","text":"","categories":[],"tags":[{"name":"编程范式","slug":"编程范式","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"}]},{"title":"🌈-CSS选择器中nth-child和nth-type-child的区别","slug":"🌈-CSS选择器中nth-child和nth-type-child的区别","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.091Z","comments":true,"path":"2021/undefined/10/🌈-CSS选择器中nth-child和nth-type-child的区别/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8C%88-CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%ADnth-child%E5%92%8Cnth-type-child%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"🌈-space-between和space-around的区别？","slug":"🌈-space-between和space-around的区别？","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.092Z","comments":true,"path":"2021/undefined/10/🌈-space-between和space-around的区别？/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8C%88-space-between%E5%92%8Cspace-around%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/","excerpt":"","text":"","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"🌈--css-flex-多列等高","slug":"🌈--css-flex-多列等高","date":"2021-01-10T16:00:00.000Z","updated":"2022-06-10T01:04:40.090Z","comments":true,"path":"2021/undefined/10/🌈--css-flex-多列等高/","link":"","permalink":"http://example.com/2021/undefined/10/%F0%9F%8C%88--css-flex-%E5%A4%9A%E5%88%97%E7%AD%89%E9%AB%98/","excerpt":"","text":"1.父元素设置display:flex2.子元素设置 flex:1 12345678910111213141516171819202122#container&#123; width:400px; margin:0 auto; background-color: #ddd; display:flex;&#125;// 不要设置 align-items 属性.left,.right&#123; display:1; width:200px; font-size: 16px; line-height:24px; color:#333;&#125;.left&#123; background-color: deeppink;&#125;.right&#123; background-color:yellowgreen;&#125; https://codepen.io/qiudaoermu/pen/rNzPMPz","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"💻-计算机显示与二进制的关系","slug":"💻-计算机显示与二进制的关系","date":"2021-01-05T16:00:00.000Z","updated":"2022-06-10T01:04:40.246Z","comments":true,"path":"2021/undefined/05/💻-计算机显示与二进制的关系/","link":"","permalink":"http://example.com/2021/undefined/05/%F0%9F%92%BB-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"1.计算机显示计算机屏幕是由像素构成的，颜色是由计算机内部的颜色系统控制，然后通过显示器三色枪打出的颜色混合而成，三色枪，分为红、绿、蓝(RGB) ,涉及到屏幕硬件知识。 2.计算机色彩体系颜色空间：RGB，CMY，HSV，HSL，Lab，按照通用的RBG标准，如下图所示rbg有6位16进制表示，16 &#x3D; 2^4, 4 * 6 &#x3D; 24,所以，rgb有 2 ^ 24 &#x3D; 16777216种可能，总共显示16777216种颜色取值范围：0~16777215, 就是3个byte 3.计算机上有多少像素以mac 电脑为例 分辨率为2560 * 1600 &#x3D; 4096000像素。24位，就是每个像素3个byte, 4096000像素 * 3 &#x3D; 12288000byte &#x3D; 11.7M; 4.大型游戏与显卡大型游戏，需要更多的灯光，材质渲染，尤其是3D游戏，需要更多显存和高频GPU参与渲染计算，计算机不只有CPU还有GPU 5.二极管简史发光二极管(Lighted Electronic Diode)作为显示器材早期仅应用于仪器仪表等低亮度领域，随着半导体材料技术的不断发展，亮度逐渐提高，稳定性及寿命逐渐延长，色彩逐渐丰富，迅速进入大屏幕工程显示领域。尤其在体育场馆等场合的应用，因其超高亮度，色彩鲜艳，长寿稳定，已成一统天下之势。而近几年LED显示材料的产量迅猛增长，成本迅速下降，使其进入户内高密度大屏幕市场成为可能。户内LED大屏幕的发展呈现如下几个发展阶段： 1． 第一代 单色LED显示屏 以单红色为基色，显示文字及简单图案为主，主要用于通知通告及客流引导系统。 2． 第二代 双基色多灰度显示屏 以红色及黄绿色为基色，因没有蓝色，只能称其为伪彩色，可以显示多灰度图象及视频，目前在国内广泛应用于电信，银行，税务，医院，政府机构等场合，主要显示标语，公益广告及形象宣传信息。 3． 第三代 全彩色(full color)多灰度显示屏 以红色，蓝色及黄绿色为基色，可以显示较为真实的图象，目前正在逐渐替代上一代产品。 4． 第四代 真彩色(true color)多灰度显示屏 以红色，蓝色及纯绿色为基色，可以真实再现自然界的一切色彩(在色坐标上甚至超过了自然色彩范围)。可以显示各种视频图象及彩色广告，其艳丽的色彩，鲜亮的高亮度，细腻的对比度，在宣传广告领域应用具有极好的视觉震撼力 6.不同图片使用的二进制位数","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"💻-一个汉字多个字节是什么意思","slug":"💻-一个汉字多个字节是什么意思","date":"2021-01-04T16:00:00.000Z","updated":"2022-06-10T01:04:40.245Z","comments":true,"path":"2021/undefined/04/💻-一个汉字多个字节是什么意思/","link":"","permalink":"http://example.com/2021/undefined/04/%F0%9F%92%BB-%E4%B8%80%E4%B8%AA%E6%B1%89%E5%AD%97%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/","excerpt":"","text":"在计算机系统中，一个汉字为什么用多个字节表示 1.什么是字节？字节(byte)是计算机存储基本单位1byte &#x3D; 8 bit, 二进制数系统中，每个0或1就是一个位（bit）。字符是最基本单位，1byte &#x3D; 8bit。比如一个文件是3byte,那么 其中是 3个，8位二进制，比如ABC，就是，0110 0001，0110 0010，0110 0011bit 中文名称是位，音译“比特”，是用以描bai述电脑数据量的最小单位。 bit 来自binary digit （二进制数字），由数学家John Wilder Tukey提出（可能是1946年提出，但有资料称1943年就提出了）。这个术语第一次被正式使用，是在香农著名的论文《通信的数学理论》(A Mathematical Theory of Communication)第1页中。 2.为什么 1byte &#x3D; 8 bit ？先了解下ASCII码 最初计算机是美国人发明的，美国人觉得128个字符够用了。ASCII表中一共 128个字符 128 &#x3D;&#x3D; 2^7128 二进制表示， 1111111，0 二级制表示 0000000 需要7位。 原始的ASCII编码是7位的，所以有2^7&#x3D;128个字符（包括一zhi些不可显示字符）。但是dao电脑里1Byte&#x3D;8bit，有8位。早期的电脑不太可靠，数据经常出错，所以这1Byte的8位中最高为就用来做数据校验，一般是奇偶校验。但是后来的电脑变得可靠了，校验的意义就没有那么大了，因此有了一个扩展ASCII字符集。扩展ASCII字符集包含2^8&#x3D;256个字符，编码是8位的。扩展ASCII字符集中的前128个字符与原来的ASCII字符集相同（就是原来的ASCII字符集的7位编码前面加一个0），而后面128个字符高位都是1。 随着计算机的发展和深入，7位的字符有时已不够用，为此国际标准化组织又制定了ISO2022标准，它在保持ISO646兼容的基础上，规定了扩充ASCII字符集为8位代码，可表示256个字符.。 ps(C&#x2F;C++的标准中，从来没有规定1byte等于8bit 。它只规定了：sizeof(char) &#x3D; 1，除此之外，还有一项相关的规定就是：sizeof(char) &lt;&#x3D; sizeof(short) &lt;&#x3D; sizeof(int) &lt;&#x3D; sizeof(long) &lt;&#x3D; sizeof(long long)。 但是现实中，1byte确实绝大部分都是8bit的。其源头是tcp&#x2F;ip协议中，有这样的规定。 所以，除非你做的系统不准备支持tcp&#x2F;ip协议，否则，依循它的协议，使用1byte&#x3D;8bit是最简单的) 3.其它语言怎么用二进制表示随着计算机的流行，许多国家需要将自己的文字加入到计算机中，但是ASCII已经满了，于是出现了新的标准，Unicode，采用16进制表示编码，转换为二进制最多为21位。 汉字 16 进制 二进制 一 4e00 100111000000000 Unicode的缺点：，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。于是出现了UTF(UTF是“Unicode Transformation Format”的缩写)UTF对应编码 Unicode编码(十六进制) UTF-8 字节流(二进制) 000000-00007F 0xxxxxxx 000080-0007FF 110xxxxx 10xxxxxx 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。 例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。 4.为什么一个汉字用多个字节表示这是因为，在UTF-8中，为了节约空间，也为了兼容ASCII编码系统，将Unicode中原本用2个字节表示的字符表示成1~4个字节（具体转换规则在这里不赘述了），其中大多数汉字部分（比如“汉”）在UTF-8中为3字节，但是在中国大陆地区，GBK编码依然很常用，在GBK中，除ASCII字符外，都是一个字符占两个字节。所以，一个汉字占多少字节还是具体取决于编码","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"📖-计算机自学之路","slug":"📖-计算机自学之路","date":"2020-12-29T16:00:00.000Z","updated":"2022-06-10T01:04:40.245Z","comments":true,"path":"2020/undefined/29/📖-计算机自学之路/","link":"","permalink":"http://example.com/2020/undefined/29/%F0%9F%93%96-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"大学四年课程 优秀书籍计算机原理 - 《计算机系统概论》 《计算机是怎么跑起来的》 《程序是怎么跑起来 的》 - 《深入理解计算机系统》 硬件原理 《电路原理》 《单片机原理与应用技术》 《彩色电视机技术原理及维修》 《QBasic程序设计》 编译原理 - 《现代编译原理：C语言描述（修订版）》（虎书） 《Crafting Interpreters》 《编译原理》（龙书） 《两周自制脚本语言》 《游戏脚本高级编程》操作系统 《自己动手写操作系统》 《操作系统导论》算法 《算法》（第4版）网络 《计算机网络 - 自顶向下方法》 《图解三部曲》 《TCP&#x2F;IP 详解卷一：协议》 《Wireshark 网络分析就是这么简单》 数据库《漫画数据库》 科技读物 《浪潮之巅》 《为什么：关于因果关系的新科学》 最后，读书学习切记囫囵吞枣，嚼碎，消化，吸收，弄懂为主，形成正向循环。 顶尖中文大学计算机专业课程体系","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"🦜🦜vuejs-第二次点击按钮-事件时出现TypeError--n-apply-is-not-a-function","slug":"🦜🦜vuejs-第二次点击按钮-事件时出现TypeError--n-apply-is-not-a-function","date":"2020-12-23T16:00:00.000Z","updated":"2022-06-10T01:04:40.098Z","comments":true,"path":"2020/undefined/23/🦜🦜vuejs-第二次点击按钮-事件时出现TypeError--n-apply-is-not-a-function/","link":"","permalink":"http://example.com/2020/undefined/23/%F0%9F%A6%9C%F0%9F%A6%9Cvuejs-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE-%E4%BA%8B%E4%BB%B6%E6%97%B6%E5%87%BA%E7%8E%B0TypeError--n-apply-is-not-a-function/","excerpt":"","text":"add 是方法又是属性，第一次点击之后，this.add &#x3D; true 成为一个属性第二点击，add 就会报错","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌈最近做项目碰到的几个css小问题总结","slug":"🌈最近做项目碰到的几个css小问题总结","date":"2020-11-23T16:00:00.000Z","updated":"2022-06-10T01:04:40.098Z","comments":true,"path":"2020/undefined/23/🌈最近做项目碰到的几个css小问题总结/","link":"","permalink":"http://example.com/2020/undefined/23/%F0%9F%8C%88%E6%9C%80%E8%BF%91%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%A2%B0%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AAcss%E5%B0%8F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"#1.display img变形 123456789&lt;div&gt; &lt;img class=&#x27;icon&#x27;/&gt; &lt;p&gt;发票&lt;/p&gt;&lt;/div&gt;&lt;style&gt;div &#123; display:flex;&#125;&lt;/style&gt; ######原因：父元素，没设置 item-align 默认 sketch，导致图片被拉伸 在w3c上找到了解释： If the cross size property of the flex item computes to auto, and neither of the cross-axis margins are auto, the flex item is stretched. Its used value is the length necessary to make the cross size of the item’s margin box as close to the same size as the line as possible, while still respecting the constraints imposed by min-height&#x2F;min-width&#x2F;max-height&#x2F;max-width. 如果一个元素没设置 item-align属性，或者margin不为 auto,图片高度会覆盖交叉轴高度，同时仍然遵守最小高度&#x2F;最小宽度&#x2F;最大高度&#x2F;最大宽度所施加的约束######解决办法:父元素设置 item-align: center#2.子元素margin-top 父元素为什么掉下来 12345678910111213141516&lt;style&gt;.bar &#123; height: 5rem; background: #2b3cbf; position: relative&#125;.bar img &#123; width: 60%; margin-top: 1rem; height: 100%; margin-left: auto;&#125;&lt;/style&gt;&lt;div class=&quot;bar&quot;&gt; &lt;img src=&quot;/img/bar.6aa5b7d1.svg&quot;/&gt;&lt;/div&gt; ######原因：相邻元素之间没有border,margin,padding,并且在一个bfc里就会产生边距合并######解决办法：如上所说，给bar元素加上 border margin padding,或者让bar元素产生一个新的bfc，都可以解决问题 123456.bar&#123; height: 5rem; background: #2b3cbf; position: relative; border-top: 1px solid #ddd; 设置一个上边距&#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"-🌦🌦lodash常用方法","slug":"-🌦🌦lodash常用方法","date":"2019-12-04T16:00:00.000Z","updated":"2022-06-10T01:04:40.097Z","comments":true,"path":"2019/undefined/04/-🌦🌦lodash常用方法/","link":"","permalink":"http://example.com/2019/undefined/04/-%F0%9F%8C%A6%F0%9F%8C%A6lodash%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"找数组中的相同key项的对象() intersectionBy 12_.intersectionBy([&#123; &#x27;x&#x27;: 1 &#125;], [&#123; &#x27;x&#x27;: 2 &#125;, &#123; &#x27;x&#x27;: 1 &#125;], &#x27;x&#x27;);// =&gt; [&#123; &#x27;x&#x27;: 1 &#125;] 去重uniqBy12_.uniqBy([&#123; &#x27;x&#x27;: 1 &#125;, &#123; &#x27;x&#x27;: 2 &#125;, &#123; &#x27;x&#x27;: 1 &#125;], &#x27;x&#x27;);// =&gt; [&#123; &#x27;x&#x27;: 1 &#125;, &#123; &#x27;x&#x27;: 2 &#125;] 返回符合元素的 index，否则返回 -1。findIndex1234567var users = [ &#123; &#x27;user&#x27;: &#x27;barney&#x27;, &#x27;active&#x27;: false &#125;, &#123; &#x27;user&#x27;: &#x27;fred&#x27;, &#x27;active&#x27;: false &#125;, &#123; &#x27;user&#x27;: &#x27;pebbles&#x27;, &#x27;active&#x27;: true &#125;];_.findIndex(users, &#123; &#x27;user&#x27;: &#x27;fred&#x27;, &#x27;active&#x27;: false &#125;);// =&gt; 1 4.深克隆cloneDeep123456var objects = [&#123; &#x27;a&#x27;: 1 &#125;, &#123; &#x27;b&#x27;: 2 &#125;];var deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]);// =&gt; false 5.取差集differenceBy12_.differenceBy([&#123; &#x27;x&#x27;: 2 &#125;, &#123; &#x27;x&#x27;: 1 &#125;], [&#123; &#x27;x&#x27;: 1 &#125;], &#x27;x&#x27;);// =&gt; [&#123; &#x27;x&#x27;: 2 &#125;]","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🦕🦕---React-如何阻止事件冒泡？","slug":"🦕🦕---React-如何阻止事件冒泡？","date":"2018-12-07T16:00:00.000Z","updated":"2022-06-10T01:04:40.097Z","comments":true,"path":"2018/undefined/07/🦕🦕---React-如何阻止事件冒泡？/","link":"","permalink":"http://example.com/2018/undefined/07/%F0%9F%A6%95%F0%9F%A6%95---React-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F/","excerpt":"","text":"React 为提高性能，有自己的一套事件处理机制，相当于将事件代理到全局进行处理，也就是说监听函数并未绑定到DOM元素上。因此，如果你禁止react事件冒泡e.stopPropagation()，你就无法阻止原生事件冒泡；你禁用原生事件冒泡e.nativeEvent.stopPropagation()，React的监听函数就调用不到了。 正确的姿势，应该是判断event.target对象，是否是目标对象、或包含的对象、或被包含的对象，来决定是否触发事件。以下函数就可以用来判断包含性： DEMO 123456789101112131415161718function contains(root, n) &#123; var node = n; while (node) &#123; if (node === root) &#123; return true; &#125; node = node.parentNode; &#125; return false;&#125;handleClick (e) &#123; if(e.target.nodeName === &#x27;li&#x27;)&#123; // do something &#125; if(contains(this.root, e.target))&#123; // do something &#125;&#125;","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🌦🌦-requestAnimationFrame-定时器","slug":"🌦🌦-requestAnimationFrame-定时器","date":"2018-12-05T16:00:00.000Z","updated":"2022-06-10T01:04:40.096Z","comments":true,"path":"2018/undefined/05/🌦🌦-requestAnimationFrame-定时器/","link":"","permalink":"http://example.com/2018/undefined/05/%F0%9F%8C%A6%F0%9F%8C%A6-requestAnimationFrame-%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"发现网上讲的太啰嗦 123456789101112var a = 0;function step()&#123; a++; console.log(a) var g = requestAnimationFrame(step) if(a&gt;=100)&#123; cancelAnimationFrame(g) &#125;&#125;step() 注意 cancelAnimationFrame(g)一定要放在后面","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]},{"title":"🧮-🧮-几个算法","slug":"🧮-🧮-几个算法","date":"2018-12-05T16:00:00.000Z","updated":"2022-06-10T01:04:40.096Z","comments":true,"path":"2018/undefined/05/🧮-🧮-几个算法/","link":"","permalink":"http://example.com/2018/undefined/05/%F0%9F%A7%AE-%F0%9F%A7%AE-%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var log = console.log;let arr = [23,45,23,46,1,100,14];function Figure()&#123;&#125;Figure.prototype = &#123; /*简单递归*/ factorial:function(number)&#123; if(number==1)&#123; return number; &#125; else &#123; return (number)*this.factorial(number-1); &#125; &#125;, /*冒泡排序*/ bubbling(arr)&#123; for(var j=0;j&lt;arr.length-1;j++)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;arr[i+1])&#123; var tepm = arr[i] arr[i] = arr[i+1]; arr[i+1] = tepm; &#125; &#125; &#125; return arr; &#125;, //找到数组中最大的三个 findMax3()&#123; var tempArr = [arr[0],arr[1],arr[2]]; for(var i=0;i&lt;arr.length;i++)&#123; var min = this.findMin(tempArr); if(arr[i]&gt;min[0])&#123; tempArr[min[1]] = arr[i]; &#125; &#125; return tempArr; &#125;, findMin(ca)&#123; var t = ca[0]; var v = &#x27;&#x27;; for(var i=0;i&lt;ca.length;i++)&#123; if(ca[i]&lt;t)&#123; t = ca[i]; &#125; &#125; for(var j=0;j&lt;ca.length;j++)&#123; if(t==ca[j])&#123; v = j; &#125; &#125; return [t,v]; &#125;&#125;;var f = new Figure(); log(f.bubbling(arr))log(f.findMax3(arr));","categories":[],"tags":[{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"}]}],"categories":[],"tags":[{"name":"实践堂","slug":"实践堂","permalink":"http://example.com/tags/%E5%AE%9E%E8%B7%B5%E5%A0%82/"},{"name":"编程范式","slug":"编程范式","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"},{"name":"开发日常","slug":"开发日常","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/"},{"name":"美食记录","slug":"美食记录","permalink":"http://example.com/tags/%E7%BE%8E%E9%A3%9F%E8%AE%B0%E5%BD%95/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"正则","slug":"正则","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"mac小天地","slug":"mac小天地","permalink":"http://example.com/tags/mac%E5%B0%8F%E5%A4%A9%E5%9C%B0/"}]}